"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/math/index.ts
var math_exports = {};
__export(math_exports, {
  clamp: () => clamp,
  inRange: () => inRange,
  mean: () => mean,
  meanBy: () => meanBy,
  random: () => random,
  randomInt: () => randomInt,
  range: () => range,
  round: () => round,
  sum: () => sum
});
module.exports = __toCommonJS(math_exports);

// src/math/clamp.ts
function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}

// src/math/inRange.ts
function inRange(value, minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("The maximum value must be greater than the minimum value.");
  }
  return minimum <= value && value < maximum;
}

// src/math/sum.ts
function sum(nums) {
  let result = 0;
  for (const num of nums) {
    result += num;
  }
  return result;
}

// src/math/mean.ts
function mean(nums) {
  return sum(nums) / nums.length;
}

// src/math/meanBy.ts
function meanBy(items, getValue) {
  const nums = items.map((x) => getValue(x));
  return mean(nums);
}

// src/math/random.ts
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}

// src/math/randomInt.ts
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}

// src/math/round.ts
function round(value, precision = 0) {
  if (!Number.isInteger(precision)) {
    throw new Error("Precision must be an integer.");
  }
  const multiplier = Math.pow(10, precision);
  return Math.round(value * multiplier) / multiplier;
}

// src/math/range.ts
function range(start, end, step) {
  if (end == null) {
    end = start;
    start = 0;
  }
  if (step == null) {
    step = 1;
  }
  if (!Number.isInteger(step) || step === 0) {
    throw new Error(`The step value must be a non-zero integer.`);
  }
  const length = Math.max(Math.ceil((end - start) / step), 0);
  const result = new Array(length);
  for (let i = 0; i < length; i++) {
    result[i] = start + i * step;
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  clamp,
  inRange,
  mean,
  meanBy,
  random,
  randomInt,
  range,
  round,
  sum
});
//# sourceMappingURL=index.js.map
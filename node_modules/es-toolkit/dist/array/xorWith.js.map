{"version":3,"sources":["../../src/array/xorWith.ts","../../src/array/differenceWith.ts","../../src/array/intersectionWith.ts","../../src/array/uniqWith.ts","../../src/array/unionWith.ts"],"sourcesContent":["import { differenceWith } from './differenceWith.ts';\nimport { intersectionWith } from './intersectionWith.ts';\nimport { unionWith } from './unionWith.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom equality function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection.\n *\n * @template T - Type of elements in the input arrays.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\n *\n * @example\n * // Custom equality function for objects with an 'id' property\n * const areObjectsEqual = (a, b) => a.id === b.id;\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areElementsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  const union = unionWith(arr1, arr2, areElementsEqual);\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\n\n  return differenceWith(union, intersection, areElementsEqual);\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {T[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n */\nexport function differenceWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n */\nexport function intersectionWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (const item of arr) {\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { uniqWith } from './uniqWith.ts';\n\n/**\n * Creates an array of unique values from two given arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\n * a new array containing only the unique values as determined by the custom equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array of unique values based on the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }];\n * const array2 = [{ id: 2 }, { id: 3 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = unionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\n */\nexport function unionWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areItemsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACqBO,SAAS,eACd,UACA,WACA,eACK;AACL,SAAO,SAAS,OAAO,eAAa;AAClC,WAAO,UAAU,MAAM,gBAAc;AACnC,aAAO,CAAC,cAAc,WAAW,UAAU;AAAA,IAC7C,CAAC;AAAA,EACH,CAAC;AACH;;;ACTO,SAAS,iBACd,UACA,WACA,eACK;AACL,SAAO,SAAS,OAAO,eAAa;AAClC,WAAO,UAAU,KAAK,gBAAc;AAClC,aAAO,cAAc,WAAW,UAAU;AAAA,IAC5C,CAAC;AAAA,EACH,CAAC;AACH;;;ACjBO,SAAS,SAAY,KAAmB,eAAqD;AAClG,QAAM,SAAc,CAAC;AAErB,aAAW,QAAQ,KAAK;AACtB,UAAM,SAAS,OAAO,MAAM,OAAK,CAAC,cAAc,GAAG,IAAI,CAAC;AAExD,QAAI,QAAQ;AACV,aAAO,KAAK,IAAI;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;;;ACLO,SAAS,UACd,MACA,MACA,eACK;AACL,SAAO,SAAS,KAAK,OAAO,IAAI,GAAG,aAAa;AAClD;;;AJNO,SAAS,QACd,MACA,MACA,kBACK;AACL,QAAM,QAAQ,UAAU,MAAM,MAAM,gBAAgB;AACpD,QAAM,eAAe,iBAAiB,MAAM,MAAM,gBAAgB;AAElE,SAAO,eAAe,OAAO,cAAc,gBAAgB;AAC7D;","names":[]}
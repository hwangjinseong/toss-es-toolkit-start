"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/array/index.ts
var array_exports = {};
__export(array_exports, {
  chunk: () => chunk,
  compact: () => compact,
  countBy: () => countBy,
  difference: () => difference,
  differenceBy: () => differenceBy,
  differenceWith: () => differenceWith,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRightWhile: () => dropRightWhile,
  dropWhile: () => dropWhile,
  fill: () => fill,
  flatten: () => flatten,
  forEachRight: () => forEachRight,
  groupBy: () => groupBy,
  head: () => head,
  intersection: () => intersection,
  intersectionBy: () => intersectionBy,
  intersectionWith: () => intersectionWith,
  keyBy: () => keyBy,
  maxBy: () => maxBy,
  minBy: () => minBy,
  orderBy: () => orderBy,
  partition: () => partition,
  sample: () => sample,
  sampleSize: () => sampleSize,
  shuffle: () => shuffle,
  tail: () => tail,
  take: () => take,
  takeRight: () => takeRight,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq,
  uniqBy: () => uniqBy,
  uniqWith: () => uniqWith,
  unzip: () => unzip,
  unzipWith: () => unzipWith,
  without: () => without,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip,
  zipObject: () => zipObject,
  zipWith: () => zipWith
});
module.exports = __toCommonJS(array_exports);

// src/array/chunk.ts
function chunk(arr, size) {
  if (!Number.isInteger(size) || size <= 0) {
    throw new Error("Size must be an integer greater than zero.");
  }
  const chunkLength = Math.ceil(arr.length / size);
  const result = Array(chunkLength);
  for (let index = 0; index < chunkLength; index++) {
    const start = index * size;
    const end = start + size;
    result[index] = arr.slice(start, end);
  }
  return result;
}

// src/array/compact.ts
function compact(arr) {
  const result = [];
  for (const item of arr) {
    if (item) {
      result.push(item);
    }
  }
  return result;
}

// src/array/countBy.ts
function countBy(arr, mapper) {
  var _a;
  const result = {};
  for (const item of arr) {
    const key = mapper(item);
    result[key] = ((_a = result[key]) != null ? _a : 0) + 1;
  }
  return result;
}

// src/array/difference.ts
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => !secondSet.has(item));
}

// src/array/differenceBy.ts
function differenceBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
  return firstArr.filter((item) => {
    return !mappedSecondSet.has(mapper(item));
  });
}

// src/array/differenceWith.ts
function differenceWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.every((secondItem) => {
      return !areItemsEqual(firstItem, secondItem);
    });
  });
}

// src/array/drop.ts
function drop(arr, itemsCount) {
  return arr.slice(itemsCount);
}

// src/array/dropRight.ts
function dropRight(arr, itemsCount) {
  return arr.slice(0, -itemsCount);
}

// src/array/dropWhile.ts
function dropWhile(arr, canContinueDropping) {
  const dropEndIndex = arr.findIndex((item) => !canContinueDropping(item));
  if (dropEndIndex === -1) {
    return [];
  }
  return arr.slice(dropEndIndex);
}

// src/array/dropRightWhile.ts
function dropRightWhile(arr, canContinueDropping) {
  const reversed = arr.slice().reverse();
  const dropped = dropWhile(reversed, canContinueDropping);
  return dropped.slice().reverse();
}

// src/array/fill.ts
function fill(arr, value, start = 0, end = arr.length) {
  start = Math.max(start, 0);
  end = Math.min(end, arr.length);
  for (let i = start; i < end; i++) {
    arr[i] = value;
  }
  return arr;
}

// src/array/flatten.ts
function flatten(arr, depth = 1) {
  const result = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (const item of arr2) {
      if (Array.isArray(item) && currentDepth < flooredDepth) {
        recursive(item, currentDepth + 1);
      } else {
        result.push(item);
      }
    }
  };
  recursive(arr, 0);
  return result;
}

// src/array/forEachRight.ts
function forEachRight(arr, callback) {
  for (let i = arr.length - 1; i >= 0; i--) {
    const element = arr[i];
    callback(element, i, arr);
  }
}

// src/array/groupBy.ts
function groupBy(arr, getKeyFromItem) {
  const result = {};
  for (const item of arr) {
    const key = getKeyFromItem(item);
    if (result[key] == null) {
      result[key] = [];
    }
    result[key].push(item);
  }
  return result;
}

// src/array/intersection.ts
function intersection(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => {
    return secondSet.has(item);
  });
}

// src/array/intersectionBy.ts
function intersectionBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map(mapper));
  return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
}

// src/array/intersectionWith.ts
function intersectionWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.some((secondItem) => {
      return areItemsEqual(firstItem, secondItem);
    });
  });
}

// src/array/keyBy.ts
function keyBy(arr, getKeyFromItem) {
  const result = {};
  for (const item of arr) {
    const key = getKeyFromItem(item);
    result[key] = item;
  }
  return result;
}

// src/array/maxBy.ts
function maxBy(items, getValue) {
  let maxElement = items[0];
  let max = -Infinity;
  for (const element of items) {
    const value = getValue(element);
    if (value > max) {
      max = value;
      maxElement = element;
    }
  }
  return maxElement;
}

// src/array/minBy.ts
function minBy(items, getValue) {
  let minElement = items[0];
  let min = Infinity;
  for (const element of items) {
    const value = getValue(element);
    if (value < min) {
      min = value;
      minElement = element;
    }
  }
  return minElement;
}

// src/array/orderBy.ts
function orderBy(collection, keys, orders) {
  const compareValues = (a, b, order) => {
    if (a < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  };
  const effectiveOrders = keys.map((_, index) => orders[index] || orders[orders.length - 1]);
  return collection.slice().sort((a, b) => {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const order = effectiveOrders[i];
      const result = compareValues(a[key], b[key], order);
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  });
}

// src/array/partition.ts
function partition(arr, isInTruthy) {
  const truthy = [];
  const falsy = [];
  for (const item of arr) {
    if (isInTruthy(item)) {
      truthy.push(item);
    } else {
      falsy.push(item);
    }
  }
  return [truthy, falsy];
}

// src/array/sample.ts
function sample(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

// src/math/random.ts
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}

// src/math/randomInt.ts
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}

// src/array/sampleSize.ts
function sampleSize(array, size) {
  if (size > array.length) {
    throw new Error("Size must be less than or equal to the length of array.");
  }
  const result = new Array(size);
  const selected = /* @__PURE__ */ new Set();
  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {
    let index = randomInt(0, step + 1);
    if (selected.has(index)) {
      index = step;
    }
    selected.add(index);
    result[resultIndex] = array[index];
  }
  return result;
}

// src/array/shuffle.ts
function shuffle(arr) {
  const result = arr.slice();
  for (let i = result.length - 1; i >= 1; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

// src/array/take.ts
function take(arr, count) {
  return arr.slice(0, count);
}

// src/array/takeRight.ts
function takeRight(arr, count) {
  if (count === 0) {
    return [];
  }
  return arr.slice(-count);
}

// src/array/takeRightWhile.ts
function takeRightWhile(arr, shouldContinueTaking) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (!shouldContinueTaking(arr[i])) {
      return arr.slice(i + 1);
    }
  }
  return arr.slice();
}

// src/array/takeWhile.ts
function takeWhile(arr, shouldContinueTaking) {
  const result = [];
  for (const item of arr) {
    if (!shouldContinueTaking(item)) {
      break;
    }
    result.push(item);
  }
  return result;
}

// src/array/uniq.ts
function uniq(arr) {
  return Array.from(new Set(arr));
}

// src/array/union.ts
function union(arr1, arr2) {
  return uniq(arr1.concat(arr2));
}

// src/array/unionBy.ts
function unionBy(arr1, arr2, mapper) {
  const map = /* @__PURE__ */ new Map();
  for (const item of [...arr1, ...arr2]) {
    const key = mapper(item);
    if (!map.has(key)) {
      map.set(key, item);
    }
  }
  return Array.from(map.values());
}

// src/array/uniqWith.ts
function uniqWith(arr, areItemsEqual) {
  const result = [];
  for (const item of arr) {
    const isUniq = result.every((v) => !areItemsEqual(v, item));
    if (isUniq) {
      result.push(item);
    }
  }
  return result;
}

// src/array/unionWith.ts
function unionWith(arr1, arr2, areItemsEqual) {
  return uniqWith(arr1.concat(arr2), areItemsEqual);
}

// src/array/uniqBy.ts
function uniqBy(arr, mapper) {
  const map = /* @__PURE__ */ new Map();
  for (const item of arr) {
    const key = mapper(item);
    if (!map.has(key)) {
      map.set(key, item);
    }
  }
  return Array.from(map.values());
}

// src/array/unzip.ts
function unzip(zipped) {
  let maxLen = 0;
  for (let i = 0; i < zipped.length; i++) {
    if (zipped[i].length > maxLen) {
      maxLen = zipped[i].length;
    }
  }
  const result = new Array(maxLen);
  for (let i = 0; i < maxLen; i++) {
    result[i] = new Array(zipped.length);
    for (let j = 0; j < zipped.length; j++) {
      result[i][j] = zipped[j][i];
    }
  }
  return result;
}

// src/array/unzipWith.ts
function unzipWith(target, iteratee) {
  const maxLength = Math.max(...target.map((innerArray) => innerArray.length));
  const result = new Array(maxLength);
  for (let i = 0; i < maxLength; i++) {
    const group = new Array(target.length);
    for (let j = 0; j < target.length; j++) {
      group[j] = target[j][i];
    }
    result[i] = iteratee(...group);
  }
  return result;
}

// src/array/xor.ts
function xor(arr1, arr2) {
  return difference(union(arr1, arr2), intersection(arr1, arr2));
}

// src/array/xorBy.ts
function xorBy(arr1, arr2, mapper) {
  const union2 = unionBy(arr1, arr2, mapper);
  const intersection2 = intersectionBy(arr1, arr2, mapper);
  return differenceBy(union2, intersection2, mapper);
}

// src/array/xorWith.ts
function xorWith(arr1, arr2, areElementsEqual) {
  const union2 = unionWith(arr1, arr2, areElementsEqual);
  const intersection2 = intersectionWith(arr1, arr2, areElementsEqual);
  return differenceWith(union2, intersection2, areElementsEqual);
}

// src/array/zip.ts
function zip(...arrs) {
  const result = [];
  const maxIndex = Math.max(...arrs.map((x) => x.length));
  for (let i = 0; i < maxIndex; i++) {
    const element = [];
    for (const arr of arrs) {
      element.push(arr[i]);
    }
    result.push(element);
  }
  return result;
}

// src/array/zipObject.ts
function zipObject(keys, values) {
  const result = {};
  for (let i = 0; i < keys.length; i++) {
    result[keys[i]] = values[i];
  }
  return result;
}

// src/array/zipWith.ts
function zipWith(arr1, ...rest) {
  const arrs = [arr1, ...rest.slice(0, -1)];
  const combine = rest[rest.length - 1];
  const result = [];
  const maxIndex = Math.max(...arrs.map((arr) => arr.length));
  for (let i = 0; i < maxIndex; i++) {
    const elements = arrs.map((arr) => arr[i]);
    result.push(combine(...elements));
  }
  return result;
}

// src/array/without.ts
function without(array, ...values) {
  const valuesSet = new Set(values);
  return array.filter((item) => !valuesSet.has(item));
}

// src/array/head.ts
function head(arr) {
  return arr[0];
}

// src/array/tail.ts
function tail(arr) {
  const len = arr.length;
  if (len <= 1) {
    return [];
  }
  const result = new Array(len - 1);
  for (let i = 1; i < len; i++) {
    result[i - 1] = arr[i];
  }
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  chunk,
  compact,
  countBy,
  difference,
  differenceBy,
  differenceWith,
  drop,
  dropRight,
  dropRightWhile,
  dropWhile,
  fill,
  flatten,
  forEachRight,
  groupBy,
  head,
  intersection,
  intersectionBy,
  intersectionWith,
  keyBy,
  maxBy,
  minBy,
  orderBy,
  partition,
  sample,
  sampleSize,
  shuffle,
  tail,
  take,
  takeRight,
  takeRightWhile,
  takeWhile,
  union,
  unionBy,
  unionWith,
  uniq,
  uniqBy,
  uniqWith,
  unzip,
  unzipWith,
  without,
  xor,
  xorBy,
  xorWith,
  zip,
  zipObject,
  zipWith
});
//# sourceMappingURL=index.js.map
{"version":3,"sources":["../../src/function/index.ts","../../src/function/debounce.ts","../../src/function/noop.ts","../../src/function/once.ts","../../src/function/throttle.ts"],"sourcesContent":["export { debounce } from './debounce.ts';\nexport { noop } from './noop.ts';\nexport { once } from './once.ts';\nexport { throttle } from './throttle.ts';\n","interface DebounceOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns {F & { cancel: () => void }} A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal }: DebounceOptions = {}\n): F & { cancel: () => void } {\n  let timeoutId: number | null = null;\n\n  const debounced = function (...args: Parameters<F>) {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    if (signal?.aborted) {\n      return;\n    }\n\n    timeoutId = setTimeout(() => {\n      func(...args);\n      timeoutId = null;\n    }, debounceMs) as any;\n  } as F & { cancel: () => void };\n\n  const onAbort = function () {\n    debounced.cancel();\n  };\n\n  debounced.cancel = function () {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  signal?.addEventListener('abort', onAbort, { once: true });\n\n  return debounced;\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F} func - The function to restrict.\n * @returns {F} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends () => any>(func: F): F {\n  let called = false;\n  let cache: ReturnType<F> | undefined;\n\n  return function () {\n    if (called) {\n      return cache;\n    }\n\n    const result = func();\n\n    called = true;\n    cache = result;\n\n    return result;\n  } as F;\n}\n","/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @returns {F} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<F extends (...args: any[]) => void>(func: F, throttleMs: number): F {\n  let lastCallTime: number | null;\n\n  const throttledFunction = function (...args: Parameters<F>) {\n    const now = Date.now();\n\n    if (lastCallTime == null || now - lastCallTime >= throttleMs) {\n      lastCallTime = now;\n      func(...args);\n    }\n  } as F;\n\n  return throttledFunction;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACuCO,SAAS,SACd,MACA,YACA,EAAE,OAAO,IAAqB,CAAC,GACH;AAC5B,MAAI,YAA2B;AAE/B,QAAM,YAAY,YAAa,MAAqB;AAClD,QAAI,cAAc,MAAM;AACtB,mBAAa,SAAS;AAAA,IACxB;AAEA,QAAI,iCAAQ,SAAS;AACnB;AAAA,IACF;AAEA,gBAAY,WAAW,MAAM;AAC3B,WAAK,GAAG,IAAI;AACZ,kBAAY;AAAA,IACd,GAAG,UAAU;AAAA,EACf;AAEA,QAAM,UAAU,WAAY;AAC1B,cAAU,OAAO;AAAA,EACnB;AAEA,YAAU,SAAS,WAAY;AAC7B,QAAI,cAAc,MAAM;AACtB,mBAAa,SAAS;AACtB,kBAAY;AAAA,IACd;AAAA,EACF;AAEA,mCAAQ,iBAAiB,SAAS,SAAS,EAAE,MAAM,KAAK;AAExD,SAAO;AACT;;;AClEO,SAAS,OAAa;AAAC;;;ACQvB,SAAS,KAA0B,MAAY;AACpD,MAAI,SAAS;AACb,MAAI;AAEJ,SAAO,WAAY;AACjB,QAAI,QAAQ;AACV,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,KAAK;AAEpB,aAAS;AACT,YAAQ;AAER,WAAO;AAAA,EACT;AACF;;;ACPO,SAAS,SAA6C,MAAS,YAAuB;AAC3F,MAAI;AAEJ,QAAM,oBAAoB,YAAa,MAAqB;AAC1D,UAAM,MAAM,KAAK,IAAI;AAErB,QAAI,gBAAgB,QAAQ,MAAM,gBAAgB,YAAY;AAC5D,qBAAe;AACf,WAAK,GAAG,IAAI;AAAA,IACd;AAAA,EACF;AAEA,SAAO;AACT;","names":[]}
{"version":3,"sources":["../src/index.ts","../src/array/chunk.ts","../src/array/compact.ts","../src/array/countBy.ts","../src/array/difference.ts","../src/array/differenceBy.ts","../src/array/differenceWith.ts","../src/array/drop.ts","../src/array/dropRight.ts","../src/array/dropWhile.ts","../src/array/dropRightWhile.ts","../src/array/fill.ts","../src/array/flatten.ts","../src/array/forEachRight.ts","../src/array/groupBy.ts","../src/array/intersection.ts","../src/array/intersectionBy.ts","../src/array/intersectionWith.ts","../src/array/keyBy.ts","../src/array/maxBy.ts","../src/array/minBy.ts","../src/array/orderBy.ts","../src/array/partition.ts","../src/array/sample.ts","../src/math/random.ts","../src/math/randomInt.ts","../src/array/sampleSize.ts","../src/array/shuffle.ts","../src/array/take.ts","../src/array/takeRight.ts","../src/array/takeRightWhile.ts","../src/array/takeWhile.ts","../src/array/uniq.ts","../src/array/union.ts","../src/array/unionBy.ts","../src/array/uniqWith.ts","../src/array/unionWith.ts","../src/array/uniqBy.ts","../src/array/unzip.ts","../src/array/unzipWith.ts","../src/array/xor.ts","../src/array/xorBy.ts","../src/array/xorWith.ts","../src/array/zip.ts","../src/array/zipObject.ts","../src/array/zipWith.ts","../src/array/without.ts","../src/array/head.ts","../src/array/tail.ts","../src/error/AbortError.ts","../src/function/debounce.ts","../src/function/noop.ts","../src/function/once.ts","../src/function/throttle.ts","../src/math/clamp.ts","../src/math/inRange.ts","../src/math/sum.ts","../src/math/mean.ts","../src/math/meanBy.ts","../src/math/round.ts","../src/math/range.ts","../src/object/omit.ts","../src/object/omitBy.ts","../src/object/pick.ts","../src/object/pickBy.ts","../src/object/invert.ts","../src/predicate/isNil.ts","../src/predicate/isNotNil.ts","../src/predicate/isNull.ts","../src/predicate/isUndefined.ts","../src/promise/delay.ts"],"sourcesContent":["/**\n * es-toolkit\n * ====================================\n * A modern JavaScript utility library that's 2-3 times faster and up to 97% smaller—a major upgrade to lodash.\n *\n * es-toolkit is a state-of-the-art, high-performance JavaScript utility library\n * with a small bundle size and strong type annotations.\n *\n * - es-toolkit offers a variety of everyday utility functions with modern implementations, such as [debounce](https://es-toolkit.slash.page/reference/function/debounce.html), [delay](https://es-toolkit.slash.page/reference/promise/delay.html), [chunk](https://es-toolkit.slash.page/reference/array/chunk.html), [sum](https://es-toolkit.slash.page/reference/math/sum.html), and [pick](https://es-toolkit.slash.page/reference/object/pick.html).\n * - Designed with performance in mind, es-toolkit achieves [2-3× better performance](https://es-toolkit.slash.page/performance.html) in modern JavaScript environments.\n * - es-toolkit supports tree shaking out of the box, and [reduces JavaScript code by up to 97%](https://es-toolkit.slash.page/bundle-size.html) compared to other libraries.\n * - es-toolkit includes built-in TypeScript support, with straightforward yet robust types. It also provides useful type guards such as [isNotNil](https://es-toolkit.slash.page/reference/predicate/isNotNil.html).\n * - es-toolkit is battle-tested with 100% test coverage, ensuring reliability and robustness.\n *\n * Here are some of the features es-toolkit offers:\n *\n * - **Array**: Utilities for array manipulation, such as [uniq](https://es-toolkit.slash.page/reference/array/uniq.html) and [difference](https://es-toolkit.slash.page/reference/array/difference.html).\n * - **Function**: Tools for controlling function execution, including [debounce](https://es-toolkit.slash.page/reference/function/debounce.html) and [throttle](https://es-toolkit.slash.page/reference/function/throttle.html).\n * - **Math**: Numerical utilities like [sum](https://es-toolkit.slash.page/reference/math/sum.html) and [round](https://es-toolkit.slash.page/reference/math/round.html).\n * - **Object**: Tools for manipulating JavaScript objects, such as [pick](https://es-toolkit.slash.page/reference/object/pick.html) and [omit](https://es-toolkit.slash.page/reference/object/omit.html).\n * - **Predicate**: Type guard functions like [isNotNil](https://es-toolkit.slash.page/reference/predicate/isNotNil.html).\n * - **Promise**: Asynchronous utilities like [delay](https://es-toolkit.slash.page/reference/promise/delay.html).\n *\n * If you want to know more about the project, please take a look at the\n * following resources:\n *\n * - [GitHub](https://github.com/toss/es-toolkit)\n * - [Documentation](https://es-toolkit.slash.page)\n *\n * @module\n */\nexport * from './array/index.ts';\nexport * from './error/index.ts';\nexport * from './function/index.ts';\nexport * from './math/index.ts';\nexport * from './object/index.ts';\nexport * from './predicate/index.ts';\nexport * from './promise/index.ts';\n","/**\n * Splits an array into smaller arrays of a specified length.\n *\n * This function takes an input array and divides it into multiple smaller arrays,\n * each of a specified length. If the input array cannot be evenly divided,\n * the final sub-array will contain the remaining elements.\n *\n * @template T The type of elements in the array.\n * @param {T[]} arr - The array to be chunked into smaller arrays.\n * @param {number} size - The size of each smaller array. Must be a positive integer.\n * @returns {T[][]} A two-dimensional array where each sub-array has a maximum length of `size`.\n * @throws {Error} Throws an error if `size` is not a positive integer.\n *\n * @example\n * // Splits an array of numbers into sub-arrays of length 2\n * chunk([1, 2, 3, 4, 5], 2);\n * // Returns: [[1, 2], [3, 4], [5]]\n *\n * @example\n * // Splits an array of strings into sub-arrays of length 3\n * chunk(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 3);\n * // Returns: [['a', 'b', 'c'], ['d', 'e', 'f'], ['g']]\n */\nexport function chunk<T>(arr: readonly T[], size: number): T[][] {\n  if (!Number.isInteger(size) || size <= 0) {\n    throw new Error('Size must be an integer greater than zero.');\n  }\n\n  const chunkLength = Math.ceil(arr.length / size);\n  const result: T[][] = Array(chunkLength);\n\n  for (let index = 0; index < chunkLength; index++) {\n    const start = index * size;\n    const end = start + size;\n\n    result[index] = arr.slice(start, end);\n  }\n\n  return result;\n}\n","type NotFalsey<T> = Exclude<T, false | null | 0 | '' | undefined>;\n\n/**\n * Removes falsey values (false, null, 0, '', undefined, NaN) from an array.\n *\n * @template T - The type of elements in the array.\n * @param {readonly T[]} arr - The input array to remove falsey values.\n * @returns {Array<Exclude<T, false | null | 0 | '' | undefined>>} - A new array with all falsey values removed.\n *\n * @example\n * compact([0, 1, false, 2, '', 3, null, undefined, 4, NaN, 5]);\n * Returns: [1, 2, 3, 4, 5]\n */\nexport function compact<T>(arr: readonly T[]): Array<NotFalsey<T>> {\n  const result: Array<NotFalsey<T>> = [];\n\n  for (const item of arr) {\n    if (item) {\n      result.push(item as NotFalsey<T>);\n    }\n  }\n\n  return result;\n}\n","/**\n * Count the occurrences of each item in an array\n * based on a transformation function.\n *\n * This function takes an array and a transformation function\n * that converts each item in the array to a string. It then\n * counts the occurrences of each transformed item and returns\n * an object with the transformed items as keys and the counts\n * as values.\n *\n * @template T - The type of the items in the input array.\n *\n * @param {T[]} arr - The input array to count occurrences.\n * @param {(item: T) => string} mapper - The transformation function that maps each item to a string key.\n * @returns {Record<string, number>} An object containing the transformed items as keys and the\n * counts as values.\n */\nexport function countBy<T>(arr: T[], mapper: (item: T) => string): Record<string, number> {\n  const result: Record<string, number> = {};\n  \n  for (const item of arr) {\n    const key = mapper(item);\n    \n    result[key] = (result[key] ?? 0) + 1;\n  }\n  \n  return result;\n}\n","/**\n * Computes the difference between two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements\n * that are present in the first array but not in the second array. It effectively\n * filters out any elements from the first array that also appear in the second array.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to derive the difference. This is the primary array\n * from which elements will be compared and filtered.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * Each element in this array will be checked against the first array, and if a match is found,\n * that element will be excluded from the result.\n * @returns {T[]} A new array containing the elements that are present in the first array but not\n * in the second array.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [2, 4];\n * const result = difference(array1, array2);\n * // result will be [1, 3, 5] since 2 and 4 are in both arrays and are excluded from the result.\n */\nexport function difference<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => !secondSet.has(item));\n}\n","/**\n * Computes the difference between two arrays after mapping their elements through a provided function.\n *\n * This function takes two arrays and a mapper function. It returns a new array containing the elements\n * that are present in the first array but not in the second array, based on the identity calculated\n * by the mapper function.\n *\n * Essentially, it filters out any elements from the first array that, when\n * mapped, match an element in the mapped version of the second array.\n *\n * @template T, U\n * @param {T[]} firstArr - The primary array from which to derive the difference.\n * @param {T[]} secondArr - The array containing elements to be excluded from the first array.\n * @param {(value: T) => U} mapper - The function to map the elements of both arrays. This function\n * is applied to each element in both arrays, and the comparison is made based on the mapped values.\n * @returns {T[]} A new array containing the elements from the first array that do not have a corresponding\n * mapped identity in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = differenceBy(array1, array2, mapper);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are in both arrays and are excluded from the result.\n */\nexport function differenceBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (value: T) => U): T[] {\n  const mappedSecondSet = new Set(secondArr.map(item => mapper(item)));\n\n  return firstArr.filter(item => {\n    return !mappedSecondSet.has(mapper(item));\n  });\n}\n","/**\n * Computes the difference between two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom comparison function. It returns a new array containing\n * the elements that are present in the first array but not in the second array. The comparison to determine\n * if elements are equal is made using the provided custom function.\n *\n * @template T\n * @param {T[]} firstArr - The array from which to get the difference.\n * @param {T[]} secondArr - The array containing elements to exclude from the first array.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A function to determine if two items are equal.\n * @returns {T[]} A new array containing the elements from the first array that do not match any elements in the second array\n * according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = differenceWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 3 }] since the elements with id 2 are considered equal and are excluded from the result.\n */\nexport function differenceWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.every(secondItem => {\n      return !areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Removes a specified number of elements from the beginning of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the start.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the beginning of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the start.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = drop(array, 2);\n * // result will be [3, 4, 5] since the first two elements are dropped.\n */\nexport function drop<T>(arr: readonly T[], itemsCount: number): T[] {\n  return arr.slice(itemsCount);\n}\n","/**\n * Removes a specified number of elements from the end of an array and returns the rest.\n *\n * This function takes an array and a number, and returns a new array with the specified number\n * of elements removed from the end.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {number} itemsCount - The number of elements to drop from the end of the array.\n * @returns {T[]} A new array with the specified number of elements removed from the end.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRight(array, 2);\n * // result will be [1, 2, 3] since the last two elements are dropped.\n */\nexport function dropRight<T>(arr: readonly T[], itemsCount: number): T[] {\n  return arr.slice(0, -itemsCount);\n}\n","/**\n * Removes elements from the beginning of an array until the predicate returns false.\n *\n * This function iterates over an array and drops elements from the start until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element, and dropping\n * continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropWhile(array, x => x < 3);\n * // result will be [3, 4, 5] since elements less than 3 are dropped.\n */\nexport function dropWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\n  const dropEndIndex = arr.findIndex(item => !canContinueDropping(item));\n  if (dropEndIndex === -1) {\n    return [];\n  }\n\n  return arr.slice(dropEndIndex);\n}\n","import { dropWhile } from './dropWhile.ts';\n\n/**\n * Removes elements from the end of an array until the predicate returns false.\n *\n * This function iterates over an array from the end and drops elements until the provided\n * predicate function returns false. It then returns a new array with the remaining elements.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array from which to drop elements.\n * @param {(item: T) => boolean} canContinueDropping - A predicate function that determines\n * whether to continue dropping elements. The function is called with each element from the end,\n * and dropping continues as long as it returns true.\n * @returns {T[]} A new array with the elements remaining after the predicate returns false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const result = dropRightWhile(array, x => x > 3);\n * // result will be [1, 2, 3] since elements greater than 3 are dropped from the end.\n */\nexport function dropRightWhile<T>(arr: readonly T[], canContinueDropping: (item: T) => boolean): T[] {\n  const reversed = arr.slice().reverse();\n  const dropped = dropWhile(reversed, canContinueDropping);\n  return dropped.slice().reverse();\n}\n","/**\n * Fills elements of an array with a specified value from the start position up to, but not including, the end position.\n *\n * This function mutates the original array and replaces its elements with the provided value, starting from the specified\n * start index up to the end index (non-inclusive). If the start or end indices are not provided, it defaults to filling the\n * entire array. Negative indices can be used to specify positions from the end of the array.\n *\n * @param {Array<T | P>} arr - The array to fill.\n * @param {P} value - The value to fill the array with.\n * @param {number} [start=0] - The start position. Defaults to 0.\n * @param {number} [end=arr.length] - The end position. Defaults to the array's length.\n * @returns {Array<T | P>} The array with the filled values.\n *\n * @example\n * const array = [1, 2, 3];\n * const result = fill(array, 'a');\n * // => ['a', 'a', 'a']\n *\n * const result = fill(Array(3), 2);\n * // => [2, 2, 2]\n *\n * const result = fill([4, 6, 8, 10], '*', 1, 3);\n * // => [4, '*', '*', 10]\n */\n\nexport function fill<T>(arr: unknown[], value: T): T[];\nexport function fill<T, P>(arr: Array<T | P>, value: P, start: number): Array<T | P>;\nexport function fill<T, P>(arr: Array<T | P>, value: P, start: number, end: number): Array<T | P>;\nexport function fill<T, P>(arr: Array<T | P>, value: P, start = 0, end = arr.length): Array<T | P> {\n  start = Math.max(start, 0);\n  end = Math.min(end, arr.length);\n\n  for (let i = start; i < end; i++) {\n    arr[i] = value;\n  }\n\n  return arr;\n}\n","/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (const item of arr) {\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n","/**\n * Iterates over elements of 'arr' from right to left and invokes 'callback' for each element.\n * \n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to iterate over.\n * @param {(value: T, index: number, arr: T[]) => void} callback - The function invoked per iteration.\n * The callback function receives three arguments:\n *  - 'value': The current element being processed in the array.\n *  - 'index': The index of the current element being processed in the array.\n *  - 'arr': The array 'forEachRight' was called upon.\n * \n * @example\n * const array = [1, 2, 3];\n * const result: number[] = [];\n * \n * // Use the forEachRight function to iterate through the array and add each element to the result array.\n * forEachRight(array, (value) => {\n *  result.push(value);\n * })\n * \n * console.log(result) // Output: [3, 2, 1]\n */\n\nexport function forEachRight<T>(arr: T[], callback: (value: T, index: number, arr: T[]) => void): void {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const element = arr[i];\n    callback(element, i, arr);\n  }\n}\n","/**\n * Groups the elements of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are arrays of elements that share\n * the same key.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array to group.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T[]>} An object where each key is associated with an array of elements that\n * share that key.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = groupBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: [\n * //     { category: 'fruit', name: 'apple' },\n * //     { category: 'fruit', name: 'banana' }\n * //   ],\n * //   vegetable: [\n * //     { category: 'vegetable', name: 'carrot' }\n * //   ]\n * // }\n */\nexport function groupBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T[]> {\n  const result = {} as Record<K, T[]>;\n\n  for (const item of arr) {\n    const key = getKeyFromItem(item);\n\n    if (result[key] == null) {\n      result[key] = [];\n    }\n\n    result[key].push(item);\n  }\n\n  return result;\n}\n","/**\n * Returns the intersection of two arrays.\n *\n * This function takes two arrays and returns a new array containing the elements that are\n * present in both arrays. It effectively filters out any elements from the first array that\n * are not found in the second array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @returns {T[]} A new array containing the elements that are present in both arrays.\n *\n * @example\n * const array1 = [1, 2, 3, 4, 5];\n * const array2 = [3, 4, 5, 6, 7];\n * const result = intersection(array1, array2);\n * // result will be [3, 4, 5] since these elements are in both arrays.\n */\nexport function intersection<T>(firstArr: readonly T[], secondArr: readonly T[]): T[] {\n  const secondSet = new Set(secondArr);\n\n  return firstArr.filter(item => {\n    return secondSet.has(item);\n  });\n}\n","/**\n * Returns the intersection of two arrays based on a mapping function.\n *\n * This function takes two arrays and a mapping function. It returns a new array containing\n * the elements from the first array that, when mapped using the provided function, have matching\n * mapped elements in the second array. It effectively filters out any elements from the first array\n * that do not have corresponding mapped values in the second array.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @param {(item: T) => U} mapper - A function to map the elements of both arrays for comparison.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding mapped values in the second array.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const mapper = item => item.id;\n * const result = intersectionBy(array1, array2, mapper);\n * // result will be [{ id: 2 }] since only this element has a matching id in both arrays.\n */\nexport function intersectionBy<T, U>(firstArr: readonly T[], secondArr: readonly T[], mapper: (item: T) => U): T[] {\n  const mappedSecondSet = new Set(secondArr.map(mapper));\n  return firstArr.filter(item => mappedSecondSet.has(mapper(item)));\n}\n","/**\n * Returns the intersection of two arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function. It returns a new array containing\n * the elements from the first array that have matching elements in the second array, as determined\n * by the custom equality function. It effectively filters out any elements from the first array that\n * do not have corresponding matches in the second array according to the equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} firstArr - The first array to compare.\n * @param {T[]} secondArr - The second array to compare.\n * @param {(x: T, y: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * This function takes two arguments, one from each array, and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array containing the elements from the first array that have corresponding matches in the second array according to the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }];\n * const array2 = [{ id: 2 }, { id: 4 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = intersectionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 2 }] since this element has a matching id in both arrays.\n */\nexport function intersectionWith<T>(\n  firstArr: readonly T[],\n  secondArr: readonly T[],\n  areItemsEqual: (x: T, y: T) => boolean\n): T[] {\n  return firstArr.filter(firstItem => {\n    return secondArr.some(secondItem => {\n      return areItemsEqual(firstItem, secondItem);\n    });\n  });\n}\n","/**\n * Maps each element of an array based on a provided key-generating function.\n *\n * This function takes an array and a function that generates a key from each element. It returns\n * an object where the keys are the generated keys and the values are the corresponding elements.\n * If there are multiple elements generating the same key, the last element among them is used\n * as the value.\n *\n * @template T - The type of elements in the array.\n * @template K - The type of keys.\n * @param {T[]} arr - The array of elements to be mapped.\n * @param {(item: T) => K} getKeyFromItem - A function that generates a key from an element.\n * @returns {Record<K, T>} An object where keys are mapped to each element of an array.\n *\n * @example\n * const array = [\n *   { category: 'fruit', name: 'apple' },\n *   { category: 'fruit', name: 'banana' },\n *   { category: 'vegetable', name: 'carrot' }\n * ];\n * const result = keyBy(array, item => item.category);\n * // result will be:\n * // {\n * //   fruit: { category: 'fruit', name: 'banana' },\n * //   vegetable: { category: 'vegetable', name: 'carrot' }\n * // }\n */\nexport function keyBy<T, K extends PropertyKey>(arr: readonly T[], getKeyFromItem: (item: T) => K): Record<K, T> {\n  const result = {} as Record<K, T>;\n\n  for (const item of arr) {\n    const key = getKeyFromItem(item);\n    result[key] = item;\n  }\n\n  return result;\n}\n","/**\n * Finds the element in an array that has the maximum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the maximum value as determined by the `getValue` function.\n * @example\n * maxBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 3 }\n * maxBy([], x => x.a); // Returns: undefined\n */\nexport function maxBy<T>(items: T[], getValue: (element: T) => number): T {\n  let maxElement = items[0];\n  let max = -Infinity;\n\n  for (const element of items) {\n    const value = getValue(element);\n    if (value > max) {\n      max = value;\n      maxElement = element;\n    }\n  }\n\n  return maxElement;\n}\n","/**\n * Finds the element in an array that has the minimum value when applying\n * the `getValue` function to each element.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items The array of elements to search.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {T} The element with the minimum value as determined by the `getValue` function.\n * @example\n * minBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: { a: 1 }\n * minBy([], x => x.a); // Returns: undefined\n */\nexport function minBy<T>(items: T[], getValue: (element: T) => number): T {\n  let minElement = items[0];\n  let min = Infinity;\n\n  for (const element of items) {\n    const value = getValue(element);\n    if (value < min) {\n      min = value;\n      minElement = element;\n    }\n  }\n\n  return minElement;\n}\n","type Order = 'asc' | 'desc';\n\n/**\n * Sorts an array of objects based on multiple properties and their corresponding order directions.\n *\n * This function takes an array of objects, an array of keys to sort by, and an array of order directions.\n * It returns the sorted array, ordering by each key according to its corresponding direction\n * ('asc' for ascending or 'desc' for descending). If values for a key are equal,\n * it moves to the next key to determine the order.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} collection - The array of objects to be sorted.\n * @param {Array<keyof T>} keys - An array of keys (properties) by which to sort.\n * @param {Order[]} orders - An array of order directions ('asc' for ascending or 'desc' for descending).\n * @returns {T[]} - The sorted array.\n *\n * @example\n * // Sort an array of objects by 'user' in ascending order and 'age' in descending order.\n * const users = [\n *   { user: 'fred', age: 48 },\n *   { user: 'barney', age: 34 },\n *   { user: 'fred', age: 40 },\n *   { user: 'barney', age: 36 },\n * ];\n * const result = orderBy(users, ['user', 'age'], ['asc', 'desc']);\n * // result will be:\n * // [\n * //   { user: 'barney', age: 36 },\n * //   { user: 'barney', age: 34 },\n * //   { user: 'fred', age: 48 },\n * //   { user: 'fred', age: 40 },\n * // ]\n */\nexport function orderBy<T>(collection: T[], keys: Array<keyof T>, orders: Order[]): T[] {\n  const compareValues = (a: T[keyof T], b: T[keyof T], order: Order) => {\n    if (a < b) {\n      return order === 'asc' ? -1 : 1;\n    }\n    if (a > b) {\n      return order === 'asc' ? 1 : -1;\n    }\n    return 0;\n  };\n\n  const effectiveOrders = keys.map((_, index) => orders[index] || orders[orders.length - 1]);\n\n  return collection.slice().sort((a, b) => {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const order = effectiveOrders[i];\n      const result = compareValues(a[key], b[key], order);\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  });\n}\n","/**\n * Splits an array into two groups based on a predicate function.\n *\n * This function takes an array and a predicate function. It returns a tuple of two arrays:\n * the first array contains elements for which the predicate function returns true, and\n * the second array contains elements for which the predicate function returns false.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to partition.\n * @param {(value: T) => boolean} isInTruthy - A predicate function that determines\n * whether an element should be placed in the truthy array. The function is called with each\n * element of the array.\n * @returns {[T[], T[]]} A tuple containing two arrays: the first array contains elements for\n * which the predicate returned true, and the second array contains elements for which the\n * predicate returned false.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const isEven = x => x % 2 === 0;\n * const [even, odd] = partition(array, isEven);\n * // even will be [2, 4], and odd will be [1, 3, 5]\n */\nexport function partition<T>(arr: readonly T[], isInTruthy: (value: T) => boolean): [truthy: T[], falsy: T[]] {\n  const truthy: T[] = [];\n  const falsy: T[] = [];\n\n  for (const item of arr) {\n    if (isInTruthy(item)) {\n      truthy.push(item);\n    } else {\n      falsy.push(item);\n    }\n  }\n\n  return [truthy, falsy];\n}\n","/**\n * Returns a random element from an array.\n *\n * This function takes an array and returns a single element selected randomly from the array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to sample from.\n * @returns {T} A random element from the array.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const randomElement = sample(array);\n * // randomElement will be one of the elements from the array, selected randomly.\n */\nexport function sample<T>(arr: readonly T[]): T {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n","/**\n * Generate a random number within the given range.\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random number between minimum (inclusive) and maximum (exclusive). The number can be an integer or a decimal.\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result1 = random(0, 5); // Returns a random number between 0 and 5.\n * const result2 = random(5, 0); // If the minimum is greater than the maximum, an error is thrown\n * const result3 = random(5, 5); // If the minimum is equal to the maximum, an error is thrown.\n */\nexport function random(maximum: number): number;\nexport function random(minimum: number, maximum: number): number;\nexport function random(minimum: number, maximum?: number): number {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('Invalid input: The maximum value must be greater than the minimum value.');\n  }\n\n  return Math.random() * (maximum - minimum) + minimum;\n}\n","import { random } from './random.ts';\n\n/**\n * Generates a random integer between minimum (inclusive) and maximum (exclusive).\n *\n * If only one argument is provided, a number between `0` and the given number is returned.\n *\n * @param {number} minimum - The lower bound (inclusive).\n * @param {number} maximum - The upper bound (exclusive).\n * @returns {number} A random integer between minimum (inclusive) and maximum (exclusive).\n * @throws {Error} Throws an error if `maximum` is not greater than `minimum`.\n *\n * @example\n * const result = randomInt(0, 5); // result will be a random integer between 0 (inclusive) and 5 (exclusive)\n * const result2 = randomInt(5, 0); // This will throw an error\n */\nexport function randomInt(maximum: number): number;\nexport function randomInt(minimum: number, maximum: number): number;\nexport function randomInt(minimum: number, maximum?: number): number {\n  return Math.floor(random(minimum, maximum!));\n}\n","import { randomInt } from '../math/randomInt.ts';\n\n/**\n * Returns a sample element array of a specified `size`.\n *\n * This function takes an array and a number, and returns an array containing the sampled elements using Floyd's algorithm.\n *\n * {@link https://www.nowherenearithaca.com/2013/05/robert-floyds-tiny-and-beautiful.html Floyd's algoritm}\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to sample from.\n * @param {number} size - The size of sample.\n * @returns {T[]} A new array with sample size applied.\n * @throws {Error} Throws an error if `size` is greater than the length of `array`.\n *\n * @example\n * const result = sampleSize([1, 2, 3], 2)\n * // result will be an array containing two of the elements from the array.\n * // [1, 2] or [1, 3] or [2, 3]\n */\nexport function sampleSize<T>(array: readonly T[], size: number): T[] {\n  if (size > array.length) {\n    throw new Error('Size must be less than or equal to the length of array.');\n  }\n\n  const result = new Array(size);\n  const selected = new Set();\n\n  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {\n    let index = randomInt(0, step + 1);\n\n    if (selected.has(index)) {\n      index = step;\n    }\n\n    selected.add(index);\n\n    result[resultIndex] = array[index];\n  }\n\n  return result;\n}\n","/**\n * Randomizes the order of elements in an array using the Fisher-Yates algorithm.\n *\n * This function takes an array and returns a new array with its elements shuffled in a random order.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to shuffle.\n * @returns {T[]} A new array with its elements shuffled in random order.\n *\n * @example\n * const array = [1, 2, 3, 4, 5];\n * const shuffledArray = shuffle(array);\n * // shuffledArray will be a new array with elements of array in random order, e.g., [3, 1, 4, 5, 2]\n */\nexport function shuffle<T>(arr: readonly T[]): T[] {\n  const result = arr.slice();\n\n  /**\n   * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n   */\n  for (let i = result.length - 1; i >= 1; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n\n  return result;\n}\n","/**\n * Returns a new array containing the first `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {number} count - The number of elements to take.\n * @returns {T[]} A new array containing the first `count` elements from `arr`.\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3, 4, 5], 3);\n *\n * @example\n * // Returns ['a', 'b']\n * take(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * take([1, 2, 3], 5);\n */\nexport function take<T>(arr: readonly T[], count: number): T[] {\n  return arr.slice(0, count);\n}\n","/**\n * Returns a new array containing the last `count` elements from the input array `arr`.\n * If `count` is greater than the length of `arr`, the entire array is returned.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to take elements from.\n * @param {number} count - The number of elements to take.\n * @returns {T[]} A new array containing the last `count` elements from `arr`.\n *\n * @example\n * // Returns [4, 5]\n * takeRight([1, 2, 3, 4, 5], 2);\n *\n * @example\n * // Returns ['b', 'c']\n * takeRight(['a', 'b', 'c'], 2);\n *\n * @example\n * // Returns [1, 2, 3]\n * takeRight([1, 2, 3], 5);\n */\nexport function takeRight<T>(arr: readonly T[], count: number): T[] {\n  if (count === 0) {\n    return [];\n  }\n\n  return arr.slice(-count);\n}\n","/**\n * Takes elements from the end of the array while the predicate function returns `true`.\n *\n * @template T - Type of elements in the input array.\n *\n * @param {T[]} arr - The array to take elements from.\n * @param {function(T): boolean} shouldContinueTaking - The function invoked per element.\n * @returns {T[]} A new array containing the elements taken from the end while the predicate returns `true`.\n *\n * @example\n * // Returns [3, 2, 1]\n * takeRightWhile([5, 4, 3, 2, 1], n => n < 4);\n *\n * @example\n * // Returns []\n * takeRightWhile([1, 2, 3], n => n > 3);\n */\nexport function takeRightWhile<T>(arr: readonly T[], shouldContinueTaking: (item: T) => boolean): T[] {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (!shouldContinueTaking(arr[i])) {\n      return arr.slice(i + 1);\n    }\n  }\n\n  return arr.slice();\n}\n","/**\n * Returns a new array containing the leading elements of the provided array\n * that satisfy the provided predicate function. It stops taking elements as soon\n * as an element does not satisfy the predicate.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(element: T) => boolean} shouldContinueTaking - The predicate function that is called with each element. Elements are included in the result as long as this function returns true.\n * @returns {T[]} A new array containing the leading elements that satisfy the predicate.\n *\n * @example\n * // Returns [1, 2]\n * takeWhile([1, 2, 3, 4], x => x < 3);\n *\n * @example\n * // Returns []\n * takeWhile([1, 2, 3, 4], x => x > 3);\n */\nexport function takeWhile<T>(arr: readonly T[], shouldContinueTaking: (element: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (const item of arr) {\n    if (!shouldContinueTaking(item)) {\n      break;\n    }\n\n    result.push(item);\n  }\n\n  return result;\n}\n","/**\n * Creates a duplicate-free version of an array.\n *\n * This function takes an array and returns a new array containing only the unique values\n * from the original array, preserving the order of first occurrence.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @returns {T[]} A new array with only unique values from the original array.\n *\n * @example\n * const array = [1, 2, 2, 3, 4, 4, 5];\n * const result = uniq(array);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function uniq<T>(arr: readonly T[]): T[] {\n  return Array.from(new Set(arr));\n}\n","import { uniq } from './uniq.ts';\n\n/**\n * Creates an array of unique values from all given arrays.\n *\n * This function takes two arrays, merges them into a single array, and returns a new array\n * containing only the unique values from the merged array.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @returns {T[]} A new array of unique values.\n *\n * @example\n * const array1 = [1, 2, 3];\n * const array2 = [3, 4, 5];\n * const result = union(array1, array2);\n * // result will be [1, 2, 3, 4, 5]\n */\nexport function union<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return uniq(arr1.concat(arr2));\n}\n","/**\n * Creates an array of unique values, in order, from all given arrays using a provided mapping function to determine equality.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} A new array containing the union of unique elements from `arr1` and `arr2`, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for numbers (modulo comparison)\n * const moduloMapper = (x) => x % 3;\n * unionBy([1, 2, 3], [4, 5, 6], moduloMapper);\n * // Returns [1, 2, 3]\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = (obj) => obj.id;\n * unionBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 2 }, { id: 3 }]\n */\nexport function unionBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (const item of [...arr1, ...arr2]) {\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the comparator function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array to process.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - The function used to compare the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the comparator function.\n *\n * @example\n * ```ts\n * uniqWith([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], (a, b) => Math.abs(a - b) < 1);\n * // [1.2, 3.2, 5.7, 7.19]\n * ```\n */\nexport function uniqWith<T>(arr: readonly T[], areItemsEqual: (item1: T, item2: T) => boolean): T[] {\n  const result: T[] = [];\n\n  for (const item of arr) {\n    const isUniq = result.every(v => !areItemsEqual(v, item));\n\n    if (isUniq) {\n      result.push(item);\n    }\n  }\n\n  return result;\n}\n","import { uniqWith } from './uniqWith.ts';\n\n/**\n * Creates an array of unique values from two given arrays based on a custom equality function.\n *\n * This function takes two arrays and a custom equality function, merges the arrays, and returns\n * a new array containing only the unique values as determined by the custom equality function.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array to merge and filter for unique values.\n * @param {T[]} arr2 - The second array to merge and filter for unique values.\n * @param {(item1: T, item2: T) => boolean} areItemsEqual - A custom function to determine if two elements are equal.\n * It takes two arguments and returns `true` if the elements are considered equal, and `false` otherwise.\n * @returns {T[]} A new array of unique values based on the custom equality function.\n *\n * @example\n * const array1 = [{ id: 1 }, { id: 2 }];\n * const array2 = [{ id: 2 }, { id: 3 }];\n * const areItemsEqual = (a, b) => a.id === b.id;\n * const result = unionWith(array1, array2, areItemsEqual);\n * // result will be [{ id: 1 }, { id: 2 }, { id: 3 }] since { id: 2 } is considered equal in both arrays\n */\nexport function unionWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areItemsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  return uniqWith(arr1.concat(arr2), areItemsEqual);\n}\n","/**\n * Returns a new array containing only the unique elements from the original array,\n * based on the values returned by the mapper function.\n *\n * @template T - The type of elements in the array.\n * @template U - The type of mapped elements.\n * @param {T[]} arr - The array to process.\n * @param {(item: T) => U} mapper - The function used to convert the array elements.\n * @returns {T[]} A new array containing only the unique elements from the original array, based on the values returned by the mapper function.\n *\n * @example\n * ```ts\n * uniqBy([1.2, 1.5, 2.1, 3.2, 5.7, 5.3, 7.19], Math.floor);\n * // [1.2, 2.1, 3.3, 5.7, 7.19]\n * ```\n */\nexport function uniqBy<T, U>(arr: readonly T[], mapper: (item: T) => U): T[] {\n  const map = new Map<U, T>();\n\n  for (const item of arr) {\n    const key = mapper(item);\n\n    if (!map.has(key)) {\n      map.set(key, item);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","/**\n * Gathers elements in the same position in an internal array \n * from a grouped array of elements and returns them as a new array.\n *\n * @param zipped - The nested array to unzip.\n * @returns A new array of unzipped elements.\n *\n * @example\n * const zipped = [['a', true, 1],['b', false, 2]];\n * const result = unzip(zipped);\n * // result will be [['a', 'b'], [true, false], [1, 2]]\n */\nexport function unzip<T extends unknown[]>(zipped: Array<[...T]>): Unzip<T> {\n  // For performance reasons, use this implementation instead of\n  // const maxLen = Math.max(...zipped.map(arr => arr.length));\n  let maxLen = 0;\n\n  for (let i = 0; i < zipped.length; i++) {\n    if (zipped[i].length > maxLen) {\n      maxLen = zipped[i].length;\n    }\n  }\n\n  const result = new Array(maxLen) as Unzip<T>;\n\n  for (let i = 0; i < maxLen; i++) {\n    result[i] = new Array(zipped.length);\n    for (let j = 0; j < zipped.length; j++) {\n      result[i][j] = zipped[j][i];\n    }\n  }\n\n  return result;\n}\n\ntype Unzip<K extends unknown[]> = { [I in keyof K]: Array<K[I]> };\n","/**\n * Unzips an array of arrays, applying an `iteratee` function to regrouped elements.\n *\n * @template T, R\n * @param {T[][]} target - The nested array to unzip. This is an array of arrays,\n * where each inner array contains elements to be unzipped.\n * @param {(...args: T[]) => R} iteratee - A function to transform the unzipped elements.\n * @returns {R[]} A new array of unzipped and transformed elements. \n *\n * @example\n * const nestedArray = [[1, 2], [3, 4], [5, 6]];\n * const result = unzipWith(nestedArray, (item, item2, item3) => item + item2 + item3);\n * // result will be [9, 12]\n */\nexport function unzipWith<T, R>(target: readonly T[][], iteratee: (...args: T[]) => R): R[] {\n  const maxLength = Math.max(...target.map(innerArray => innerArray.length));\n  const result: R[] = new Array(maxLength);\n\n  for (let i = 0; i < maxLength; i++) {\n    const group = new Array(target.length);\n\n    for (let j = 0; j < target.length; j++) {\n      group[j] = target[j][i];\n    }\n\n    result[i] = iteratee(...group);\n  }\n\n  return result;\n}\n","import { difference } from './difference.ts';\nimport { intersection } from './intersection.ts';\nimport { union } from './union.ts';\n\n/**\n * Computes the symmetric difference between two arrays. The symmetric difference is the set of elements\n * which are in either of the arrays, but not in their intersection.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both.\n *\n * @example\n * // Returns [1, 2, 5, 6]\n * xor([1, 2, 3, 4], [3, 4, 5, 6]);\n *\n * @example\n * // Returns ['a', 'c']\n * xor(['a', 'b'], ['b', 'c']);\n */\nexport function xor<T>(arr1: readonly T[], arr2: readonly T[]): T[] {\n  return difference(union(arr1, arr2), intersection(arr1, arr2));\n}\n","import { differenceBy } from './differenceBy.ts';\nimport { intersectionBy } from './intersectionBy.ts';\nimport { unionBy } from './unionBy.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom mapping function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection, determined by the result of the mapping function.\n *\n * @template T - Type of elements in the input arrays.\n * @template U - Type of the values returned by the mapping function.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item: T) => U} mapper - The function to map array elements to comparison values.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the values returned by the mapping function.\n *\n * @example\n * // Custom mapping function for objects with an 'id' property\n * const idMapper = obj => obj.id;\n * xorBy([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], idMapper);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorBy<T, U>(arr1: readonly T[], arr2: readonly T[], mapper: (item: T) => U): T[] {\n  const union = unionBy(arr1, arr2, mapper);\n  const intersection = intersectionBy(arr1, arr2, mapper);\n\n  return differenceBy(union, intersection, mapper);\n}\n","import { differenceWith } from './differenceWith.ts';\nimport { intersectionWith } from './intersectionWith.ts';\nimport { unionWith } from './unionWith.ts';\n\n/**\n * Computes the symmetric difference between two arrays using a custom equality function.\n * The symmetric difference is the set of elements which are in either of the arrays,\n * but not in their intersection.\n *\n * @template T - Type of elements in the input arrays.\n *\n * @param {T[]} arr1 - The first array.\n * @param {T[]} arr2 - The second array.\n * @param {(item1: T, item2: T) => boolean} areElementsEqual - The custom equality function to compare elements.\n * @returns {T[]} An array containing the elements that are present in either `arr1` or `arr2` but not in both, based on the custom equality function.\n *\n * @example\n * // Custom equality function for objects with an 'id' property\n * const areObjectsEqual = (a, b) => a.id === b.id;\n * xorWith([{ id: 1 }, { id: 2 }], [{ id: 2 }, { id: 3 }], areObjectsEqual);\n * // Returns [{ id: 1 }, { id: 3 }]\n */\nexport function xorWith<T>(\n  arr1: readonly T[],\n  arr2: readonly T[],\n  areElementsEqual: (item1: T, item2: T) => boolean\n): T[] {\n  const union = unionWith(arr1, arr2, areElementsEqual);\n  const intersection = intersectionWith(arr1, arr2, areElementsEqual);\n\n  return differenceWith(union, intersection, areElementsEqual);\n}\n","/**\n * Combines multiple arrays into a single array of tuples.\n *\n * This function takes multiple arrays and returns a new array where each element is a tuple\n * containing the corresponding elements from the input arrays. If the input arrays are of\n * different lengths, the resulting array will have the length of the longest input array,\n * with undefined values for missing elements.\n *\n * @param {...T[][]} arrs - The arrays to zip together.\n * @returns {T[][]} A new array of tuples containing the corresponding elements from the input arrays.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const arr2 = ['a', 'b', 'c'];\n * const result = zip(arr1, arr2);\n * // result will be [[1, 'a'], [2, 'b'], [3, 'c']]\n *\n * const arr3 = [true, false];\n * const result2 = zip(arr1, arr2, arr3);\n * // result2 will be [[1, 'a', true], [2, 'b', false], [3, 'c', undefined]]\n */\nexport function zip<T>(arr1: readonly T[]): Array<[T]>;\nexport function zip<T, U>(arr1: readonly T[], arr2: readonly U[]): Array<[T, U]>;\nexport function zip<T, U, V>(arr1: readonly T[], arr2: readonly U[], arr3: readonly V[]): Array<[T, U, V]>;\nexport function zip<T, U, V, W>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[]\n): Array<[T, U, V, W]>;\nexport function zip<T>(...arrs: Array<readonly T[]>): T[][] {\n  const result: T[][] = [];\n\n  const maxIndex = Math.max(...arrs.map(x => x.length));\n\n  for (let i = 0; i < maxIndex; i++) {\n    const element: T[] = [];\n\n    for (const arr of arrs) {\n      element.push(arr[i]);\n    }\n\n    result.push(element);\n  }\n\n  return result;\n}\n","/**\n * Combines two arrays, one of property names and one of corresponding values, into a single object.\n *\n * This function takes two arrays: one containing property names and another containing corresponding values.\n * It returns a new object where the property names from the first array are keys, and the corresponding elements\n * from the second array are values. If the `keys` array is longer than the `values` array, the remaining keys will\n * have `undefined` as their values.\n *\n * @template P - The type of elements in the array.\n * @template V - The type of elements in the array.\n * @param {P[]} keys - An array of property names.\n * @param {V[]} values - An array of values corresponding to the property names.\n * @returns {{ [K in P]: V }} A new object composed of the given property names and values.\n *\n * @example\n * const keys = ['a', 'b', 'c'];\n * const values = [1, 2, 3];\n * const result = zipObject(keys, values);\n * // result will be { a: 1, b: 2, c: 3 }\n *\n * const keys2 = ['a', 'b', 'c'];\n * const values2 = [1, 2];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2, c: undefined }\n *\n * const keys2 = ['a', 'b'];\n * const values2 = [1, 2, 3];\n * const result2 = zipObject(keys2, values2);\n * // result2 will be { a: 1, b: 2 }\n */\nexport function zipObject<P extends string | number | symbol, V>(keys: P[], values: V[]): { [K in P]: V } {\n  const result = {} as { [K in P]: V };\n\n  for (let i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i];\n  }\n\n  return result;\n}\n","/**\n * Combines multiple arrays into a single array using a custom combiner function.\n *\n * This function takes multiple arrays and a combiner function, and returns a new array where each element\n * is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @param {T[]} arr1 - The first array to zip.\n * @param {U[]} [arr2] - The second array to zip (optional).\n * @param {V[]} [arr3] - The third array to zip (optional).\n * @param {W[]} [arr4] - The fourth array to zip (optional).\n * @param {(...items: T[]) => R} combine - The combiner function that takes corresponding elements from each array and returns a single value.\n * @returns {R[]} A new array where each element is the result of applying the combiner function to the corresponding elements of the input arrays.\n *\n * @example\n * // Example usage with two arrays:\n * const arr1 = [1, 2, 3];\n * const arr2 = [4, 5, 6];\n * const result = zipWith(arr1, arr2, (a, b) => a + b);\n * // result will be [5, 7, 9]\n *\n * @example\n * // Example usage with three arrays:\n * const arr1 = [1, 2];\n * const arr2 = [3, 4];\n * const arr3 = [5, 6];\n * const result = zipWith(arr1, arr2, arr3, (a, b, c) => `${a}${b}${c}`);\n * // result will be [`135`, `246`]\n */\nexport function zipWith<T, R>(arr1: readonly T[], combine: (item: T) => R): R[];\nexport function zipWith<T, U, R>(arr1: readonly T[], arr2: readonly U[], combine: (item1: T, item2: U) => R): R[];\nexport function zipWith<T, U, V, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  combine: (item1: T, item2: U, item3: V) => R\n): R[];\nexport function zipWith<T, U, V, W, R>(\n  arr1: readonly T[],\n  arr2: readonly U[],\n  arr3: readonly V[],\n  arr4: readonly W[],\n  combine: (item1: T, item2: U, item3: V, item4: W) => R\n): R[];\nexport function zipWith<T, R>(arr1: readonly T[], ...rest: any[]): R[] {\n  const arrs = [arr1, ...rest.slice(0, -1)];\n  const combine = rest[rest.length - 1] as (...items: T[]) => R;\n\n  const result: R[] = [];\n  const maxIndex = Math.max(...arrs.map(arr => arr.length));\n\n  for (let i = 0; i < maxIndex; i++) {\n    const elements: T[] = arrs.map(arr => arr[i]);\n    result.push(combine(...elements));\n  }\n\n  return result;\n}\n","/**\n * Creates an array that excludes all specified values.\n *\n * It correctly excludes `NaN`, as it compares values using [SameValueZero](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-samevaluezero).\n *\n * @template T The type of elements in the array.\n * @param {T[]} array - The array to filter.\n * @param {...T[]} values - The values to exclude.\n * @returns {T[]} A new array without the specified values.\n *\n * @example\n * // Removes the specified values from the array\n * without([1, 2, 3, 4, 5], 2, 4);\n * // Returns: [1, 3, 5]\n *\n * @example\n * // Removes specified string values from the array\n * without(['a', 'b', 'c', 'a'], 'a');\n * // Returns: ['b', 'c']\n */\nexport function without<T>(array: readonly T[], ...values: T[]): T[] {\n  const valuesSet = new Set(values);\n  return array.filter(item => !valuesSet.has(item));\n}\n","/**\n * Returns the first element of an array.\n *\n * This function takes an array and returns the first element of the array.\n * If the array is empty, the function returns `undefined`.\n *\n * @param {T[]} arr - The array from which to get the first element.\n * @returns {T | undefined} The first element of the array, or `undefined` if the array is empty.\n *\n * @example\n * const arr = [1, 2, 3];\n * const firstElement = head(arr);\n * // firstElement will be 1\n *\n * const emptyArr: number[] = [];\n * const noElement = head(emptyArr);\n * // noElement will be undefined\n */\nexport function head<T>(arr: readonly [T, ...T[]]): T;\nexport function head<T>(arr: readonly T[]): T | undefined;\nexport function head<T>(arr: readonly T[]): T | undefined {\n  return arr[0];\n}\n","/**\n * Returns an empty array when the input is a single-element array.\n *\n * @param {readonly [T]} arr - The single-element array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [1];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail<T>(arr: readonly [T]): [];\n\n/**\n * Returns an empty array when the input is an empty array.\n *\n * @param {readonly []} arr - The empty array to process.\n * @returns {[]} An empty array.\n *\n * @example\n * const arr = [];\n * const result = tail(arr);\n * // result will be []\n */\nexport function tail(arr: readonly []): [];\n\n/**\n * Returns a new array with all elements except for the first when the input is a tuple array.\n *\n * @param {readonly [T, ...U[]]} arr - The tuple array to process.\n * @returns {U[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr = [1, 2, 3];\n * const result = tail(arr);\n * // result will be [2, 3]\n */\nexport function tail<T, U>(arr: readonly [T, ...U[]]): U[];\n\n/**\n * Returns a new array with all elements except for the first.\n *\n * This function takes an array and returns a new array containing all the elements\n * except for the first one. If the input array is empty or has only one element,\n * an empty array is returned.\n *\n * @param {readonly T[]} arr - The array to get the tail of.\n * @returns {T[]} A new array containing all elements of the input array except for the first one.\n *\n * @example\n * const arr1 = [1, 2, 3];\n * const result = tail(arr1);\n * // result will be [2, 3]\n *\n * const arr2 = [1];\n * const result2 = tail(arr2);\n * // result2 will be []\n *\n * const arr3 = [];\n * const result3 = tail(arr3);\n * // result3 will be []\n */\nexport function tail<T>(arr: readonly T[]): T[] {\n  const len = arr.length;\n  if (len <= 1) {\n    return [];\n  }\n  const result = new Array(len - 1);\n  for (let i = 1; i < len; i++) {\n    result[i - 1] = arr[i];\n  }\n  return result;\n}\n","/**\n * An error class representing an aborted operation.\n * @augments Error\n */\nexport class AbortError extends Error {\n  constructor(message = 'The operation was aborted') {\n    super(message);\n    this.name = 'AbortError';\n  }\n}\n","interface DebounceOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after `debounceMs` milliseconds\n * have elapsed since the last time the debounced function was invoked. The debounced function also has a `cancel`\n * method to cancel any pending execution.\n *\n * @template F - The type of function.\n * @param {F} func - The function to debounce.\n * @param {number} debounceMs - The number of milliseconds to delay.\n * @param {DebounceOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the debounced function.\n * @returns {F & { cancel: () => void }} A new debounced function with a `cancel` method.\n *\n * @example\n * const debouncedFunction = debounce(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' after 1 second if not called again in that time\n * debouncedFunction();\n *\n * // Will not log anything as the previous call is canceled\n * debouncedFunction.cancel();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const signal = controller.signal;\n * const debouncedWithSignal = debounce(() => {\n *  console.log('Function executed');\n * }, 1000, { signal });\n *\n * debouncedWithSignal();\n *\n * // Will cancel the debounced function call\n * controller.abort();\n */\nexport function debounce<F extends (...args: any[]) => void>(\n  func: F,\n  debounceMs: number,\n  { signal }: DebounceOptions = {}\n): F & { cancel: () => void } {\n  let timeoutId: number | null = null;\n\n  const debounced = function (...args: Parameters<F>) {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    if (signal?.aborted) {\n      return;\n    }\n\n    timeoutId = setTimeout(() => {\n      func(...args);\n      timeoutId = null;\n    }, debounceMs) as any;\n  } as F & { cancel: () => void };\n\n  const onAbort = function () {\n    debounced.cancel();\n  };\n\n  debounced.cancel = function () {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  signal?.addEventListener('abort', onAbort, { once: true });\n\n  return debounced;\n}\n","/**\n * A no-operation function that does nothing.\n * This can be used as a placeholder or default function.\n *\n * @example\n * noop(); // Does nothing\n *\n * @returns {void} This function does not return anything.\n */\nexport function noop(): void {}\n","/**\n * Creates a function that is restricted to invoking the provided function `func` once.\n * Repeated calls to the function will return the value from the first invocation.\n *\n * @template F - The type of function.\n * @param {F} func - The function to restrict.\n * @returns {F} A new function that invokes `func` once and caches the result.\n *\n * @example\n * const initialize = once(() => {\n *   console.log('Initialized!');\n *   return true;\n * });\n *\n * initialize(); // Logs: 'Initialized!' and returns true\n * initialize(); // Returns true without logging\n */\nexport function once<F extends () => any>(func: F): F {\n  let called = false;\n  let cache: ReturnType<F> | undefined;\n\n  return function () {\n    if (called) {\n      return cache;\n    }\n\n    const result = func();\n\n    called = true;\n    cache = result;\n\n    return result;\n  } as F;\n}\n","/**\n * Creates a throttled function that only invokes the provided function at most once\n * per every `throttleMs` milliseconds. Subsequent calls to the throttled function\n * within the wait time will not trigger the execution of the original function.\n *\n * @template F - The type of function.\n * @param {F} func - The function to throttle.\n * @param {number} throttleMs - The number of milliseconds to throttle executions to.\n * @returns {F} A new throttled function that accepts the same parameters as the original function.\n *\n * @example\n * const throttledFunction = throttle(() => {\n *   console.log('Function executed');\n * }, 1000);\n *\n * // Will log 'Function executed' immediately\n * throttledFunction();\n *\n * // Will not log anything as it is within the throttle time\n * throttledFunction();\n *\n * // After 1 second\n * setTimeout(() => {\n *   throttledFunction(); // Will log 'Function executed'\n * }, 1000);\n */\nexport function throttle<F extends (...args: any[]) => void>(func: F, throttleMs: number): F {\n  let lastCallTime: number | null;\n\n  const throttledFunction = function (...args: Parameters<F>) {\n    const now = Date.now();\n\n    if (lastCallTime == null || now - lastCallTime >= throttleMs) {\n      lastCallTime = now;\n      func(...args);\n    }\n  } as F;\n\n  return throttledFunction;\n}\n","/**\n * Clamps a number within the inclusive lower and upper bounds.\n *\n * This function takes a number and two bounds, and returns the number clamped within the specified bounds.\n * If only one bound is provided, it returns the minimum of the value and the bound.\n *\n * @param {number} value - The number to clamp.\n * @param {number} minimum - The minimum bound to clamp the number.\n * @param {number} maximum - The maximum bound to clamp the number.\n * @returns {number} The clamped number within the specified bounds.\n *\n * @example\n * const result1 = clamp(10, 5); // result1 will be 5, as 10 is clamped to the bound 5\n * const result2 = clamp(10, 5, 15); // result2 will be 10, as it is within the bounds 5 and 15\n * const result3 = clamp(2, 5, 15); // result3 will be 5, as 2 is clamped to the lower bound 5\n * const result4 = clamp(20, 5, 15); // result4 will be 15, as 20 is clamped to the upper bound 15\n */\nexport function clamp(value: number, maximum: number): number;\nexport function clamp(value: number, minimum: number, maximum: number): number;\nexport function clamp(value: number, bound1: number, bound2?: number): number {\n  if (bound2 == null) {\n    return Math.min(value, bound1);\n  }\n\n  return Math.min(Math.max(value, bound1), bound2);\n}\n","export function inRange(value: number, maximum: number): boolean;\nexport function inRange(value: number, minimum: number, maximum: number): boolean;\n/**\n * Checks if the value is within a specified range.\n *\n * @param {number} value The value to check.\n * @param {number} minimum The lower bound of the range (inclusive).\n * @param {number} maximum The upper bound of the range (exclusive).\n * @returns {boolean} `true` if the value is within the specified range, otherwise `false`.\n * @throws {Error} Throws an error if the `minimum` is greater or equal than the `maximum`.\n *\n * @example\n * const result1 = inRange(3, 5); // result1 will be true.\n * const result2 = inRange(1, 2, 5); // result2 will be false.\n * const result3 = inRange(1, 5, 2); // If the minimum is greater or equal than the maximum, an error is thrown.\n */\nexport function inRange(value: number, minimum: number, maximum?: number): boolean {\n  if (maximum == null) {\n    maximum = minimum;\n    minimum = 0;\n  }\n\n  if (minimum >= maximum) {\n    throw new Error('The maximum value must be greater than the minimum value.');\n  }\n\n  return minimum <= value && value < maximum;\n}\n","/**\n * Calculates the sum of an array of numbers.\n *\n * This function takes an array of numbers and returns the sum of all the elements in the array.\n *\n * @param {number[]} nums - An array of numbers to be summed.\n * @returns {number} The sum of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = sum(numbers);\n * // result will be 15\n */\nexport function sum(nums: readonly number[]): number {\n  let result = 0;\n\n  for (const num of nums) {\n    result += num;\n  }\n\n  return result;\n}\n","import { sum } from './sum.ts';\n\n/**\n * Calculates the average of an array of numbers.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @param {number[]} nums - An array of numbers to calculate the average.\n * @returns {number} The average of all the numbers in the array.\n *\n * @example\n * const numbers = [1, 2, 3, 4, 5];\n * const result = average(numbers);\n * // result will be 3\n */\nexport function mean(nums: readonly number[]): number {\n  return sum(nums) / nums.length;\n}\n","import { mean } from './mean.ts';\n\n/**\n * Calculates the average of an array of numbers when applying\n * the `getValue` function to each element.\n *\n * If the array is empty, this function returns `NaN`.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} items An array to calculate the average.\n * @param {(element: T) => number} getValue A function that selects a numeric value from each element.\n * @returns {number} The average of all the numbers as determined by the `getValue` function.\n *\n * @example\n * meanBy([{ a: 1 }, { a: 2 }, { a: 3 }], x => x.a); // Returns: 2\n * meanBy([], x => x.a); // Returns: NaN\n */\nexport function meanBy<T>(items: readonly T[], getValue: (element: T) => number): number {\n  const nums = items.map(x => getValue(x));\n\n  return mean(nums);\n}\n","/**\n * Rounds a number to a specified precision.\n *\n * This function takes a number and an optional precision value, and returns the number rounded\n * to the specified number of decimal places.\n *\n * @param {number} value - The number to round.\n * @param {number} [precision=0] - The number of decimal places to round to. Defaults to 0.\n * @returns {number} The rounded number.\n * @throws {Error} Throws an error if `Precision` is not integer.\n *\n * @example\n * const result1 = round(1.2345); // result1 will be 1\n * const result2 = round(1.2345, 2); // result2 will be 1.23\n * const result3 = round(1.2345, 3); // result3 will be 1.235\n * const result4 = round(1.2345, 3.1); // This will throw an error\n */\nexport function round(value: number, precision = 0): number {\n  if (!Number.isInteger(precision)) {\n    throw new Error('Precision must be an integer.');\n  }\n  const multiplier = Math.pow(10, precision);\n  return Math.round(value * multiplier) / multiplier;\n}\n","/**\n * Returns an array of numbers from `start` to `end`, incrementing by `step`.\n *\n * If `step` is not provided, it defaults to `1`.\n *\n * @param {number} start - The starting number of the range (inclusive).\n * @param {number} [end] - The end number of the range (exclusive).\n * @param {number} [step] - The step value for the range. (default: 1)\n * @returns {number[]} An array of numbers from `start` to `end` with the specified `step`.\n *\n * @example\n * // Returns [0, 1, 2, 3]\n * range(4);\n *\n * @example\n * // Returns [0, 5, 10, 15]\n * range(0, 20, 5);\n *\n * @example\n * // Returns [0, -1, -2, -3]\n * range(0, -4, -1);\n *\n * @example\n * // Throws an error: The step value must be a non-zero integer.\n * range(1, 4, 0);\n */\nexport function range(end: number): number[];\nexport function range(start: number, end: number): number[];\nexport function range(start: number, end: number, step: number): number[];\nexport function range(start: number, end?: number, step?: number): number[] {\n  if (end == null) {\n    end = start;\n    start = 0;\n  }\n\n  if (step == null) {\n    step = 1;\n  }\n\n  if (!Number.isInteger(step) || step === 0) {\n    throw new Error(`The step value must be a non-zero integer.`);\n  }\n\n  const length = Math.max(Math.ceil((end - start) / step), 0);\n  const result = new Array(length);\n\n  for (let i = 0; i < length; i++) {\n    result[i] = start + i * step;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object with specified keys omitted.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * excludes the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to omit keys from.\n * @param {K[]} keys - An array of keys to be omitted from the object.\n * @returns {Omit<T, K>} A new object with the specified keys omitted.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = omit(obj, ['b', 'c']);\n * // result will be { a: 1 }\n */\nexport function omit<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n  const result = { ...obj };\n\n  for (const key of keys) {\n    delete result[key];\n  }\n\n  return result as Omit<T, K>;\n}\n","/**\n * Creates a new object composed of the properties that do not satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns false.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to omit properties from.\n * @param {(value: T[string], key: keyof T) => boolean} shouldOmit - A predicate function that determines\n * whether a property should be omitted. It takes the property's key and value as arguments and returns `true`\n * if the property should be omitted, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that do not satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'omit', c: 3 };\n * const shouldOmit = (key, value) => typeof value === 'string';\n * const result = omitBy(obj, shouldOmit);\n * // result will be { a: 1, c: 3 }\n */\nexport function omitBy<T extends Record<string, any>>(\n  obj: T,\n  shouldOmit: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (shouldOmit(value, key)) {\n      continue;\n    }\n\n    (result as any)[key] = value;\n  }\n\n  return result;\n}\n","/**\n * Creates a new object composed of the picked object properties.\n *\n * This function takes an object and an array of keys, and returns a new object that\n * includes only the properties corresponding to the specified keys.\n *\n * @template T - The type of object.\n * @template K - The type of keys in object.\n * @param {T} obj - The object to pick keys from.\n * @param {K[]} keys - An array of keys to be picked from the object.\n * @returns {Pick<T, K>} A new object with the specified keys picked.\n *\n * @example\n * const obj = { a: 1, b: 2, c: 3 };\n * const result = pick(obj, ['a', 'c']);\n * // result will be { a: 1, c: 3 }\n */\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n\n  for (const key of keys) {\n    result[key] = obj[key];\n  }\n\n  return result;\n}\n","/**\n * Creates a new object composed of the properties that satisfy the predicate function.\n *\n * This function takes an object and a predicate function, and returns a new object that\n * includes only the properties for which the predicate function returns true.\n *\n * @template T - The type of object.\n * @param {T} obj - The object to pick properties from.\n * @param {(value: T[keyof T], key: keyof T) => boolean} shouldPick - A predicate function that determines\n * whether a property should be picked. It takes the property's key and value as arguments and returns `true`\n * if the property should be picked, and `false` otherwise.\n * @returns {Partial<T>} A new object with the properties that satisfy the predicate function.\n *\n * @example\n * const obj = { a: 1, b: 'pick', c: 3 };\n * const shouldPick = (value) => typeof value === 'string';\n * const result = pickBy(obj, shouldPick);\n * // result will be { b: 'pick' }\n */\nexport function pickBy<T extends Record<string, any>>(\n  obj: T,\n  shouldPick: (value: T[keyof T], key: keyof T) => boolean\n): Partial<T> {\n  const result: Partial<T> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (!shouldPick(value, key)) {\n      continue;\n    }\n\n    (result as any)[key] = value;\n  }\n\n  return result;\n}\n","/**\n * Inverts the keys and values of an object. The keys of the input object become the values of the output object and vice versa.\n *\n * This function takes an object and creates a new object by inverting its keys and values. If the input object has duplicate values,\n * the key of the last occurrence will be used as the value for the new key in the output object. It effectively creates a reverse mapping\n * of the input object's key-value pairs.\n *\n * @template K - Type of the keys in the input object (string, number, symbol)\n * @template V - Type of the values in the input object (string, number, symbol)\n * @param {Record<K, V>} obj - The input object whose keys and values are to be inverted\n * @returns {{ [key in V]: K }} - A new object with keys and values inverted\n *\n * @example\n * invert({ a: 1, b: 2, c: 3 }); // { 1: 'a', 2: 'b', 3: 'c' }\n * invert({ 1: 'a', 2: 'b', 3: 'c' }); // { a: '1', b: '2', c: '3' }\n * invert({ a: 1, 2: 'b', c: 3, 4: 'd' }); // { 1: 'a', b: '2', 3: 'c', d: '4' }\n * invert({ a: Symbol('sym1'), b: Symbol('sym2') }); // { [Symbol('sym1')]: 'a', [Symbol('sym2')]: 'b' }\n */\nexport function invert<K extends PropertyKey, V extends PropertyKey>(obj: Record<K, V>): { [key in V]: K } {\n  const result = {} as { [key in V]: K };\n\n  for (const key in obj) {\n    const value = obj[key as K] as V;\n    result[value] = key;\n  }\n\n  return result;\n}\n","/**\n * Checks if a given value is null or undefined.\n *\n * This function tests whether the provided value is either `null` or `undefined`.\n * It returns `true` if the value is `null` or `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null` or `undefined`.\n *\n * @param {unknown} x - The value to test for null or undefined.\n * @returns {boolean} `true` if the value is null or undefined, `false` otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n * const result1 = isNil(value1); // true\n * const result2 = isNil(value2); // true\n * const result3 = isNil(value3); // false\n */\nexport function isNil(x: unknown): x is null | undefined {\n  return x === null || x === undefined;\n}\n","/**\n * Checks if the given value is not null nor undefined.\n *\n * The main use of this function is to be used with TypeScript as a type predicate.\n *\n * @template T - The type of value.\n * @param {T | null | undefined} x - The value to test if it is not null nor undefined.\n * @returns {x is T} True if the value is not null nor undefined, false otherwise.\n *\n * @example\n * // Here the type of `arr` is (number | undefined)[]\n * const arr = [1, undefined, 3];\n * // Here the type of `result` is number[]\n * const result = arr.filter(isNotNil);\n * // result will be [1, 3]\n */\nexport function isNotNil<T>(x: T | null | undefined): x is T {\n  return x !== null && x !== undefined;\n}\n","/**\n * Checks if the given value is null.\n *\n * This function tests whether the provided value is strictly equal to `null`.\n * It returns `true` if the value is `null`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `null`.\n *\n * @param {unknown} x - The value to test if it is null.\n * @returns {x is null} True if the value is null, false otherwise.\n *\n * @example\n * const value1 = null;\n * const value2 = undefined;\n * const value3 = 42;\n *\n * console.log(isNull(value1)); // true\n * console.log(isNull(value2)); // false\n * console.log(isNull(value3)); // false\n */\nexport function isNull(x: unknown): x is null {\n  return x === null;\n}\n","/**\n * Checks if the given value is undefined.\n *\n * This function tests whether the provided value is strictly equal to `undefined`.\n * It returns `true` if the value is `undefined`, and `false` otherwise.\n *\n * This function can also serve as a type predicate in TypeScript, narrowing the type of the argument to `undefined`.\n *\n * @param {unknown} x - The value to test if it is undefined.\n * @returns {x is undefined} true if the value is undefined, false otherwise.\n *\n * @example\n * const value1 = undefined;\n * const value2 = null;\n * const value3 = 42;\n *\n * console.log(isUndefined(value1)); // true\n * console.log(isUndefined(value2)); // false\n * console.log(isUndefined(value3)); // false\n */\nexport function isUndefined(x: unknown): x is undefined {\n  return x === undefined;\n}\n","import { AbortError } from '../error/AbortError.ts';\n\ninterface DelayOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n *\n * This function returns a Promise that resolves after the specified delay, allowing you to use it\n * with async/await to pause execution.\n *\n * @param {number} ms - The number of milliseconds to delay.\n * @param {DelayOptions} options - The options object.\n * @param {AbortSignal} options.signal - An optional AbortSignal to cancel the delay.\n * @returns {Promise<void>} A Promise that resolves after the specified delay.\n *\n * @example\n * async function foo() {\n *   console.log('Start');\n *   await delay(1000); // Delays execution for 1 second\n *   console.log('End');\n * }\n *\n * foo();\n *\n * // With AbortSignal\n * const controller = new AbortController();\n * const { signal } = controller;\n *\n * setTimeout(() => controller.abort(), 50); // Will cancel the delay after 50ms\n * try {\n *   await delay(100, { signal });\n *  } catch (error) {\n *   console.error(error); // Will log 'AbortError'\n *  }\n * }\n */\nexport function delay(ms: number, { signal }: DelayOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const abortError = () => {\n      reject(new AbortError());\n    };\n\n    const abortHandler = () => {\n      clearTimeout(timeoutId);\n      abortError();\n    };\n\n    if (signal?.aborted) {\n      return abortError();\n    }\n\n    const timeoutId = setTimeout(resolve, ms);\n\n    signal?.addEventListener('abort', abortHandler, { once: true });\n  });\n}\n"],"mappings":"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","names":["arr","union","intersection","union","intersection"]}
{"version":3,"sources":["../src/array/flatten.ts"],"sourcesContent":["/**\n * Flattens an array up to the specified depth.\n *\n * @template T - The type of elements within the array.\n * @template D - The depth to which the array should be flattened.\n * @param {T[]} arr - The array to flatten.\n * @param {D} depth - The depth level specifying how deep a nested array structure should be flattened. Defaults to 1.\n * @returns {Array<FlatArray<T[], D>>} A new array that has been flattened.\n *\n * @example\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 1);\n * // Returns: [1, 2, 3, 4, [5, 6]]\n *\n * const arr = flatten([1, [2, 3], [4, [5, 6]]], 2);\n * // Returns: [1, 2, 3, 4, 5, 6]\n */\nexport function flatten<T, D extends number = 1>(arr: readonly T[], depth = 1 as D): Array<FlatArray<T[], D>> {\n  const result: Array<FlatArray<T[], D>> = [];\n  const flooredDepth = Math.floor(depth);\n\n  const recursive = (arr: readonly T[], currentDepth: number) => {\n    for (const item of arr) {\n      if (Array.isArray(item) && currentDepth < flooredDepth) {\n        recursive(item, currentDepth + 1);\n      } else {\n        result.push(item as FlatArray<T[], D>);\n      }\n    }\n  };\n\n  recursive(arr, 0);\n  return result;\n}\n"],"mappings":";AAgBO,SAAS,QAAiC,KAAmB,QAAQ,GAAkC;AAC5G,QAAM,SAAmC,CAAC;AAC1C,QAAM,eAAe,KAAK,MAAM,KAAK;AAErC,QAAM,YAAY,CAACA,MAAmB,iBAAyB;AAC7D,eAAW,QAAQA,MAAK;AACtB,UAAI,MAAM,QAAQ,IAAI,KAAK,eAAe,cAAc;AACtD,kBAAU,MAAM,eAAe,CAAC;AAAA,MAClC,OAAO;AACL,eAAO,KAAK,IAAyB;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AAEA,YAAU,KAAK,CAAC;AAChB,SAAO;AACT;","names":["arr"]}
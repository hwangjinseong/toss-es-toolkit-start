"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AbortError: () => AbortError,
  chunk: () => chunk,
  clamp: () => clamp,
  compact: () => compact,
  countBy: () => countBy,
  debounce: () => debounce,
  delay: () => delay,
  difference: () => difference,
  differenceBy: () => differenceBy,
  differenceWith: () => differenceWith,
  drop: () => drop,
  dropRight: () => dropRight,
  dropRightWhile: () => dropRightWhile,
  dropWhile: () => dropWhile,
  fill: () => fill,
  flatten: () => flatten,
  forEachRight: () => forEachRight,
  groupBy: () => groupBy,
  head: () => head,
  inRange: () => inRange,
  intersection: () => intersection,
  intersectionBy: () => intersectionBy,
  intersectionWith: () => intersectionWith,
  invert: () => invert,
  isNil: () => isNil,
  isNotNil: () => isNotNil,
  isNull: () => isNull,
  isUndefined: () => isUndefined,
  keyBy: () => keyBy,
  maxBy: () => maxBy,
  mean: () => mean,
  meanBy: () => meanBy,
  minBy: () => minBy,
  noop: () => noop,
  omit: () => omit,
  omitBy: () => omitBy,
  once: () => once,
  orderBy: () => orderBy,
  partition: () => partition,
  pick: () => pick,
  pickBy: () => pickBy,
  random: () => random,
  randomInt: () => randomInt,
  range: () => range,
  round: () => round,
  sample: () => sample,
  sampleSize: () => sampleSize,
  shuffle: () => shuffle,
  sum: () => sum,
  tail: () => tail,
  take: () => take,
  takeRight: () => takeRight,
  takeRightWhile: () => takeRightWhile,
  takeWhile: () => takeWhile,
  throttle: () => throttle,
  union: () => union,
  unionBy: () => unionBy,
  unionWith: () => unionWith,
  uniq: () => uniq,
  uniqBy: () => uniqBy,
  uniqWith: () => uniqWith,
  unzip: () => unzip,
  unzipWith: () => unzipWith,
  without: () => without,
  xor: () => xor,
  xorBy: () => xorBy,
  xorWith: () => xorWith,
  zip: () => zip,
  zipObject: () => zipObject,
  zipWith: () => zipWith
});
module.exports = __toCommonJS(src_exports);

// src/array/chunk.ts
function chunk(arr, size) {
  if (!Number.isInteger(size) || size <= 0) {
    throw new Error("Size must be an integer greater than zero.");
  }
  const chunkLength = Math.ceil(arr.length / size);
  const result = Array(chunkLength);
  for (let index = 0; index < chunkLength; index++) {
    const start = index * size;
    const end = start + size;
    result[index] = arr.slice(start, end);
  }
  return result;
}

// src/array/compact.ts
function compact(arr) {
  const result = [];
  for (const item of arr) {
    if (item) {
      result.push(item);
    }
  }
  return result;
}

// src/array/countBy.ts
function countBy(arr, mapper) {
  var _a;
  const result = {};
  for (const item of arr) {
    const key = mapper(item);
    result[key] = ((_a = result[key]) != null ? _a : 0) + 1;
  }
  return result;
}

// src/array/difference.ts
function difference(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => !secondSet.has(item));
}

// src/array/differenceBy.ts
function differenceBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map((item) => mapper(item)));
  return firstArr.filter((item) => {
    return !mappedSecondSet.has(mapper(item));
  });
}

// src/array/differenceWith.ts
function differenceWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.every((secondItem) => {
      return !areItemsEqual(firstItem, secondItem);
    });
  });
}

// src/array/drop.ts
function drop(arr, itemsCount) {
  return arr.slice(itemsCount);
}

// src/array/dropRight.ts
function dropRight(arr, itemsCount) {
  return arr.slice(0, -itemsCount);
}

// src/array/dropWhile.ts
function dropWhile(arr, canContinueDropping) {
  const dropEndIndex = arr.findIndex((item) => !canContinueDropping(item));
  if (dropEndIndex === -1) {
    return [];
  }
  return arr.slice(dropEndIndex);
}

// src/array/dropRightWhile.ts
function dropRightWhile(arr, canContinueDropping) {
  const reversed = arr.slice().reverse();
  const dropped = dropWhile(reversed, canContinueDropping);
  return dropped.slice().reverse();
}

// src/array/fill.ts
function fill(arr, value, start = 0, end = arr.length) {
  start = Math.max(start, 0);
  end = Math.min(end, arr.length);
  for (let i = start; i < end; i++) {
    arr[i] = value;
  }
  return arr;
}

// src/array/flatten.ts
function flatten(arr, depth = 1) {
  const result = [];
  const flooredDepth = Math.floor(depth);
  const recursive = (arr2, currentDepth) => {
    for (const item of arr2) {
      if (Array.isArray(item) && currentDepth < flooredDepth) {
        recursive(item, currentDepth + 1);
      } else {
        result.push(item);
      }
    }
  };
  recursive(arr, 0);
  return result;
}

// src/array/forEachRight.ts
function forEachRight(arr, callback) {
  for (let i = arr.length - 1; i >= 0; i--) {
    const element = arr[i];
    callback(element, i, arr);
  }
}

// src/array/groupBy.ts
function groupBy(arr, getKeyFromItem) {
  const result = {};
  for (const item of arr) {
    const key = getKeyFromItem(item);
    if (result[key] == null) {
      result[key] = [];
    }
    result[key].push(item);
  }
  return result;
}

// src/array/intersection.ts
function intersection(firstArr, secondArr) {
  const secondSet = new Set(secondArr);
  return firstArr.filter((item) => {
    return secondSet.has(item);
  });
}

// src/array/intersectionBy.ts
function intersectionBy(firstArr, secondArr, mapper) {
  const mappedSecondSet = new Set(secondArr.map(mapper));
  return firstArr.filter((item) => mappedSecondSet.has(mapper(item)));
}

// src/array/intersectionWith.ts
function intersectionWith(firstArr, secondArr, areItemsEqual) {
  return firstArr.filter((firstItem) => {
    return secondArr.some((secondItem) => {
      return areItemsEqual(firstItem, secondItem);
    });
  });
}

// src/array/keyBy.ts
function keyBy(arr, getKeyFromItem) {
  const result = {};
  for (const item of arr) {
    const key = getKeyFromItem(item);
    result[key] = item;
  }
  return result;
}

// src/array/maxBy.ts
function maxBy(items, getValue) {
  let maxElement = items[0];
  let max = -Infinity;
  for (const element of items) {
    const value = getValue(element);
    if (value > max) {
      max = value;
      maxElement = element;
    }
  }
  return maxElement;
}

// src/array/minBy.ts
function minBy(items, getValue) {
  let minElement = items[0];
  let min = Infinity;
  for (const element of items) {
    const value = getValue(element);
    if (value < min) {
      min = value;
      minElement = element;
    }
  }
  return minElement;
}

// src/array/orderBy.ts
function orderBy(collection, keys, orders) {
  const compareValues = (a, b, order) => {
    if (a < b) {
      return order === "asc" ? -1 : 1;
    }
    if (a > b) {
      return order === "asc" ? 1 : -1;
    }
    return 0;
  };
  const effectiveOrders = keys.map((_, index) => orders[index] || orders[orders.length - 1]);
  return collection.slice().sort((a, b) => {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const order = effectiveOrders[i];
      const result = compareValues(a[key], b[key], order);
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  });
}

// src/array/partition.ts
function partition(arr, isInTruthy) {
  const truthy = [];
  const falsy = [];
  for (const item of arr) {
    if (isInTruthy(item)) {
      truthy.push(item);
    } else {
      falsy.push(item);
    }
  }
  return [truthy, falsy];
}

// src/array/sample.ts
function sample(arr) {
  const randomIndex = Math.floor(Math.random() * arr.length);
  return arr[randomIndex];
}

// src/math/random.ts
function random(minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("Invalid input: The maximum value must be greater than the minimum value.");
  }
  return Math.random() * (maximum - minimum) + minimum;
}

// src/math/randomInt.ts
function randomInt(minimum, maximum) {
  return Math.floor(random(minimum, maximum));
}

// src/array/sampleSize.ts
function sampleSize(array, size) {
  if (size > array.length) {
    throw new Error("Size must be less than or equal to the length of array.");
  }
  const result = new Array(size);
  const selected = /* @__PURE__ */ new Set();
  for (let step = array.length - size, resultIndex = 0; step < array.length; step++, resultIndex++) {
    let index = randomInt(0, step + 1);
    if (selected.has(index)) {
      index = step;
    }
    selected.add(index);
    result[resultIndex] = array[index];
  }
  return result;
}

// src/array/shuffle.ts
function shuffle(arr) {
  const result = arr.slice();
  for (let i = result.length - 1; i >= 1; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

// src/array/take.ts
function take(arr, count) {
  return arr.slice(0, count);
}

// src/array/takeRight.ts
function takeRight(arr, count) {
  if (count === 0) {
    return [];
  }
  return arr.slice(-count);
}

// src/array/takeRightWhile.ts
function takeRightWhile(arr, shouldContinueTaking) {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (!shouldContinueTaking(arr[i])) {
      return arr.slice(i + 1);
    }
  }
  return arr.slice();
}

// src/array/takeWhile.ts
function takeWhile(arr, shouldContinueTaking) {
  const result = [];
  for (const item of arr) {
    if (!shouldContinueTaking(item)) {
      break;
    }
    result.push(item);
  }
  return result;
}

// src/array/uniq.ts
function uniq(arr) {
  return Array.from(new Set(arr));
}

// src/array/union.ts
function union(arr1, arr2) {
  return uniq(arr1.concat(arr2));
}

// src/array/unionBy.ts
function unionBy(arr1, arr2, mapper) {
  const map = /* @__PURE__ */ new Map();
  for (const item of [...arr1, ...arr2]) {
    const key = mapper(item);
    if (!map.has(key)) {
      map.set(key, item);
    }
  }
  return Array.from(map.values());
}

// src/array/uniqWith.ts
function uniqWith(arr, areItemsEqual) {
  const result = [];
  for (const item of arr) {
    const isUniq = result.every((v) => !areItemsEqual(v, item));
    if (isUniq) {
      result.push(item);
    }
  }
  return result;
}

// src/array/unionWith.ts
function unionWith(arr1, arr2, areItemsEqual) {
  return uniqWith(arr1.concat(arr2), areItemsEqual);
}

// src/array/uniqBy.ts
function uniqBy(arr, mapper) {
  const map = /* @__PURE__ */ new Map();
  for (const item of arr) {
    const key = mapper(item);
    if (!map.has(key)) {
      map.set(key, item);
    }
  }
  return Array.from(map.values());
}

// src/array/unzip.ts
function unzip(zipped) {
  let maxLen = 0;
  for (let i = 0; i < zipped.length; i++) {
    if (zipped[i].length > maxLen) {
      maxLen = zipped[i].length;
    }
  }
  const result = new Array(maxLen);
  for (let i = 0; i < maxLen; i++) {
    result[i] = new Array(zipped.length);
    for (let j = 0; j < zipped.length; j++) {
      result[i][j] = zipped[j][i];
    }
  }
  return result;
}

// src/array/unzipWith.ts
function unzipWith(target, iteratee) {
  const maxLength = Math.max(...target.map((innerArray) => innerArray.length));
  const result = new Array(maxLength);
  for (let i = 0; i < maxLength; i++) {
    const group = new Array(target.length);
    for (let j = 0; j < target.length; j++) {
      group[j] = target[j][i];
    }
    result[i] = iteratee(...group);
  }
  return result;
}

// src/array/xor.ts
function xor(arr1, arr2) {
  return difference(union(arr1, arr2), intersection(arr1, arr2));
}

// src/array/xorBy.ts
function xorBy(arr1, arr2, mapper) {
  const union2 = unionBy(arr1, arr2, mapper);
  const intersection2 = intersectionBy(arr1, arr2, mapper);
  return differenceBy(union2, intersection2, mapper);
}

// src/array/xorWith.ts
function xorWith(arr1, arr2, areElementsEqual) {
  const union2 = unionWith(arr1, arr2, areElementsEqual);
  const intersection2 = intersectionWith(arr1, arr2, areElementsEqual);
  return differenceWith(union2, intersection2, areElementsEqual);
}

// src/array/zip.ts
function zip(...arrs) {
  const result = [];
  const maxIndex = Math.max(...arrs.map((x) => x.length));
  for (let i = 0; i < maxIndex; i++) {
    const element = [];
    for (const arr of arrs) {
      element.push(arr[i]);
    }
    result.push(element);
  }
  return result;
}

// src/array/zipObject.ts
function zipObject(keys, values) {
  const result = {};
  for (let i = 0; i < keys.length; i++) {
    result[keys[i]] = values[i];
  }
  return result;
}

// src/array/zipWith.ts
function zipWith(arr1, ...rest) {
  const arrs = [arr1, ...rest.slice(0, -1)];
  const combine = rest[rest.length - 1];
  const result = [];
  const maxIndex = Math.max(...arrs.map((arr) => arr.length));
  for (let i = 0; i < maxIndex; i++) {
    const elements = arrs.map((arr) => arr[i]);
    result.push(combine(...elements));
  }
  return result;
}

// src/array/without.ts
function without(array, ...values) {
  const valuesSet = new Set(values);
  return array.filter((item) => !valuesSet.has(item));
}

// src/array/head.ts
function head(arr) {
  return arr[0];
}

// src/array/tail.ts
function tail(arr) {
  const len = arr.length;
  if (len <= 1) {
    return [];
  }
  const result = new Array(len - 1);
  for (let i = 1; i < len; i++) {
    result[i - 1] = arr[i];
  }
  return result;
}

// src/error/AbortError.ts
var AbortError = class extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
};

// src/function/debounce.ts
function debounce(func, debounceMs, { signal } = {}) {
  let timeoutId = null;
  const debounced = function(...args) {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    timeoutId = setTimeout(() => {
      func(...args);
      timeoutId = null;
    }, debounceMs);
  };
  const onAbort = function() {
    debounced.cancel();
  };
  debounced.cancel = function() {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  signal == null ? void 0 : signal.addEventListener("abort", onAbort, { once: true });
  return debounced;
}

// src/function/noop.ts
function noop() {
}

// src/function/once.ts
function once(func) {
  let called = false;
  let cache;
  return function() {
    if (called) {
      return cache;
    }
    const result = func();
    called = true;
    cache = result;
    return result;
  };
}

// src/function/throttle.ts
function throttle(func, throttleMs) {
  let lastCallTime;
  const throttledFunction = function(...args) {
    const now = Date.now();
    if (lastCallTime == null || now - lastCallTime >= throttleMs) {
      lastCallTime = now;
      func(...args);
    }
  };
  return throttledFunction;
}

// src/math/clamp.ts
function clamp(value, bound1, bound2) {
  if (bound2 == null) {
    return Math.min(value, bound1);
  }
  return Math.min(Math.max(value, bound1), bound2);
}

// src/math/inRange.ts
function inRange(value, minimum, maximum) {
  if (maximum == null) {
    maximum = minimum;
    minimum = 0;
  }
  if (minimum >= maximum) {
    throw new Error("The maximum value must be greater than the minimum value.");
  }
  return minimum <= value && value < maximum;
}

// src/math/sum.ts
function sum(nums) {
  let result = 0;
  for (const num of nums) {
    result += num;
  }
  return result;
}

// src/math/mean.ts
function mean(nums) {
  return sum(nums) / nums.length;
}

// src/math/meanBy.ts
function meanBy(items, getValue) {
  const nums = items.map((x) => getValue(x));
  return mean(nums);
}

// src/math/round.ts
function round(value, precision = 0) {
  if (!Number.isInteger(precision)) {
    throw new Error("Precision must be an integer.");
  }
  const multiplier = Math.pow(10, precision);
  return Math.round(value * multiplier) / multiplier;
}

// src/math/range.ts
function range(start, end, step) {
  if (end == null) {
    end = start;
    start = 0;
  }
  if (step == null) {
    step = 1;
  }
  if (!Number.isInteger(step) || step === 0) {
    throw new Error(`The step value must be a non-zero integer.`);
  }
  const length = Math.max(Math.ceil((end - start) / step), 0);
  const result = new Array(length);
  for (let i = 0; i < length; i++) {
    result[i] = start + i * step;
  }
  return result;
}

// src/object/omit.ts
function omit(obj, keys) {
  const result = __spreadValues({}, obj);
  for (const key of keys) {
    delete result[key];
  }
  return result;
}

// src/object/omitBy.ts
function omitBy(obj, shouldOmit) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (shouldOmit(value, key)) {
      continue;
    }
    result[key] = value;
  }
  return result;
}

// src/object/pick.ts
function pick(obj, keys) {
  const result = {};
  for (const key of keys) {
    result[key] = obj[key];
  }
  return result;
}

// src/object/pickBy.ts
function pickBy(obj, shouldPick) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (!shouldPick(value, key)) {
      continue;
    }
    result[key] = value;
  }
  return result;
}

// src/object/invert.ts
function invert(obj) {
  const result = {};
  for (const key in obj) {
    const value = obj[key];
    result[value] = key;
  }
  return result;
}

// src/predicate/isNil.ts
function isNil(x) {
  return x === null || x === void 0;
}

// src/predicate/isNotNil.ts
function isNotNil(x) {
  return x !== null && x !== void 0;
}

// src/predicate/isNull.ts
function isNull(x) {
  return x === null;
}

// src/predicate/isUndefined.ts
function isUndefined(x) {
  return x === void 0;
}

// src/promise/delay.ts
function delay(ms, { signal } = {}) {
  return new Promise((resolve, reject) => {
    const abortError = () => {
      reject(new AbortError());
    };
    const abortHandler = () => {
      clearTimeout(timeoutId);
      abortError();
    };
    if (signal == null ? void 0 : signal.aborted) {
      return abortError();
    }
    const timeoutId = setTimeout(resolve, ms);
    signal == null ? void 0 : signal.addEventListener("abort", abortHandler, { once: true });
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbortError,
  chunk,
  clamp,
  compact,
  countBy,
  debounce,
  delay,
  difference,
  differenceBy,
  differenceWith,
  drop,
  dropRight,
  dropRightWhile,
  dropWhile,
  fill,
  flatten,
  forEachRight,
  groupBy,
  head,
  inRange,
  intersection,
  intersectionBy,
  intersectionWith,
  invert,
  isNil,
  isNotNil,
  isNull,
  isUndefined,
  keyBy,
  maxBy,
  mean,
  meanBy,
  minBy,
  noop,
  omit,
  omitBy,
  once,
  orderBy,
  partition,
  pick,
  pickBy,
  random,
  randomInt,
  range,
  round,
  sample,
  sampleSize,
  shuffle,
  sum,
  tail,
  take,
  takeRight,
  takeRightWhile,
  takeWhile,
  throttle,
  union,
  unionBy,
  unionWith,
  uniq,
  uniqBy,
  uniqWith,
  unzip,
  unzipWith,
  without,
  xor,
  xorBy,
  xorWith,
  zip,
  zipObject,
  zipWith
});
//# sourceMappingURL=index.js.map